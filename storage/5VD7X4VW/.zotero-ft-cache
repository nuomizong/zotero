Efï¬cient Simulation of Secondary Motion in Rig-Space
Fabian Hahn1,2 Bernhard Thomaszewski2
1

Stelian Coros2
2

Robert W. Sumner2

Markus Gross1,2

ETH Zurich

Disney Research Zurich

Figure 1: Our method augments hand-crafted character animations such as this sumo wrestler with high-quality secondary motion, using an efï¬cient rig-space simulation method.

Abstract
We present an efï¬cient method for augmenting keyframed character animations with physically-simulated secondary motion. Our method achieves a performance improvement of one to two orders of magnitude over previous work without compromising on quality. This performance is based on a linearized formulation of rigspace dynamics that uses only rig parameters as degrees of freedom, a physics-based volumetric skinning method that allows our method to predict the motion of internal vertices solely from deformations of the surface, as well as a deferred Jacobian update scheme that drastically reduces the number of required rig evaluations. We demonstrate the performance of our method by comparing it to previous work and showcase its potential on a productionquality character rig. CR Categories: I.3.7 [Computer Graphics]: Three-Dimensional Graphics and RealismâAnimation; I.6.8 [Simulation and Modeling]: Types of SimulationâAnimation Keywords: physically-based simulation, animation control

automatically computed secondary motion. The basic idea of rigspace physics is to use physics-based simulation in rig-space, the characterâs space of motion. As a key advantage over conventional physics-based simulation, the results of these simulations are animation curves that can be easily edited by artists. But while rigspace physics can automatically generate secondary motion with high visual quality, it entails a signiï¬cant computational burden that slows production and prohibits its use in interactive environments. In this paper, we present a method that offers a signiï¬cant computational improvement over the work of Hahn et al. [2012] while maintaining the same level of quality. This advance is made possible by three main contributions: â¢ a linearized formulation of rig-space dynamics using rig parameters as the only degrees of freedom, â¢ a physics-based volumetric skinning method that allows our algorithm to compute the position of internal vertices solely from the surface vertices, and â¢ a deferred Jacobian evaluation scheme that signiï¬cantly reduces the number of required rig evaluations. Taken together, these contributions allow a performance improvement of one to two orders of magnitude over the original rig-space physics method on production-quality rigs, as shown in Fig. 1.

1

Introduction

Creating believable and compelling character motions is arguably the central challenge in animated movie productions. While manually posing a character for each animation keyframe allows artists to create very expressive animations, this process is tedious when it comes to creating secondary motion such as the bulging of muscles or jiggling of fat. Hahn et al. [2012] recently presented rigspace physics, a method to augment keyframed animations with
c ACM, 2013. This is the authorâs version of the work. It is posted here by permission of ACM for your personal use. Not for redistribution. The deï¬nitive version was published in the 2013 Proceedings of the ACM SIGGRAPH/Eurographics Symposium on Computer Animation (SCA â13).

2

Related Work

Designing and animating digital characters is a central problem in computer graphics. We refer the interested reader to the recent survey by McLaughlin et al. [2011] for an overview of the many challenges involved in this task. Here, we focus on existing work related to the problem of creating secondary motions.

Before characters can be animated, they ï¬rst have to be modeled and rigged. During modeling, artists deï¬ne the surface mesh of a character, and the rigging stage requires artists to specify how this surface mesh deforms as a function of a relatively small number of rig parameters. The map between the rig parameters and the deformation of the surface mesh can be deï¬ned using a variety of different techniques: linear blend or dual quaternion skinning [Magnenat-Thalmann et al. 1989; Kavan et al. 2008], wire deformations [Singh and Fiume 1998] or blend shapes [Lewis et al. 2000; Sloan et al. 2001], to name a few. Many of these techniques are complementary, and there is no single best solution for all applications. Furthermore, the choice of which of the techniques are eventually used also depends on other factors such as personal preference. In order to afford a maximum level of generality, we follow Hahn et al. [2012] and do not make any assumptions about the underlying rig. Consequently, we evaluate the rig and its derivatives through function calls to the modeling/animation software.
Rigging and Keyframe Animation

Reduced model methods for deformable objects are typically used to improve simulation speed. The underlying idea is to formulate the equations of motion in a lowdimensional subspace onto which the full-dimensional simulation model is projected. These subspaces can be deï¬ned by applying dimensionality reduction on sequences of meshes obtained through full simulations [James and Fatahalian 2003], by embedding objects in low-resolution lattices [Faloutsos et al. 1997], by analyzing the vibration modes of an object [BarbiË et al. 2009], or by usc ing dual quaternion skinning to express the deformation of an object as a function of a small number of reference frames [Gilles et al. 2011]. While these methods are typically optimized for efï¬ciency, rig-space physics is designed to operate in the deformation subspaces deï¬ned by arbitrary animation rigs. This generality, however, comes at a heavy computational price, which we aim to signiï¬cantly lower with the method we propose.
Subspace Physics

Physics-based simulation is a natural choice for creating secondary motion effects such as ï¬esh and fat jiggling as a character moves. Since the pioneering work of Terzopoulos et al. [1987], many simulation methods that can potentially be used for this purpose have been introduced. A comprehensive review of these works is outside the scope of this manuscript, but the survey article of Nealen et al. [2006] provides more details on this topic.
Deformable Models

Most of the methods for simulating volumetric objects require the simulation domain to be spatially discretized into tetrahedrons [Irving et al. 2004]. The characters used in animation environments are typically represented by surface meshes only, but there are many well-established tools such as Tetgen, NetGen, and gmsh for generating tetrahedral meshes from boundary representations. A more fundamental difference between physics-based simulation and character animation is that simulations endow each vertex of the mesh with individual degrees of freedom. To the extent that the motion must obey physics, the vertices are thus free to move independently from each other. This setup is in stark contrast to character animation, where the high-resolution surface mesh is constrained to deform only in the subspace deï¬ned by the rig. This representational mismatch typically implies that simulation must take place at a later stage of the animation pipeline and that results cannot easily be edited by animators. The rig-space physics method of Hahn et al. [2012] was speciï¬cally designed to bypass this challenge, but it still needs to compute the motion of the internal vertices. This entails the solution of large systems of equations and, consequently, leads to high computational costs. Although there are simulation methods that do not require a volumetric representation, these are not without limitations. Shell models [Grinspun et al. 2003], for instance, can, in principle, be used to compute secondary motions on the characterâs surface. However, shell models lack volume preservation by deï¬nition and thus cannot account for the natural bulging of ï¬esh and other soft tissue. As another alternative, the boundary element method [James and Pai 1999] condenses a volumetric problem to one with degrees of freedom only on the surface. However, this method only works well for linear problems and is therefore not attractive for modeling the highly nonlinear deformations exhibited by production-quality characters. To alleviate these limitations, we aim to formulate an explicit, linear map that returns the position of interior vertices as a function of the conï¬guration of the surface mesh. In effect, the deformation of the rig is automatically propagated everywhere in the interior of the simulation mesh, allowing for a very efï¬cient implementation of subspace physics.

One of the key contributions of our method is that it enables the use of a deformation energy deï¬ned on a volumetric mesh, but without the need for additional internal degrees of freedom. We construct an explicit, example-based linear map that outputs the conï¬guration of the internal vertices as a function of the surface mesh of the character. This approach is inspired by existing methods that compute skinning weights to map the motion of a set of coordinate frames onto a surface mesh [Magnenat-Thalmann et al. 1989]. There are many methods that aim to improve the quality of skinning. Multi-linear methods [Wang and Phillips 2002] use additional weights to improve the quality, as does the recent method of Jacobson et al. [2012]. Kavan et al. [2008] show that nonlinear skinning formulations can also lead to better quality, but our goal is to construct a linear map between surface and internal vertices. Another group of methods improves skinning using example shapes [Lewis et al. 2000; Sloan et al. 2001; Kry et al. 2002], while other methods automatically compute skinning weights by optimizing for smoothness properties [Baran and PopoviÂ´ 2007; Jacobson c and Sorkine 2011]. The recent method by Kavan et al. [2012] automatically computes optimized skinning weights by minimizing an elastic energy, which is similar in spirit to our approach. However, our skinning method does not try to alter the deformation of the surface mesh but deï¬nes the behavior of the interior.
Skinning

Other research [James and Twigg 2005; Hasler et al. 2010; Kavan et al. 2010; Le and Deng 2012] speciï¬cally targets the problem of skinning animations, which entails ï¬nding transformations and corresponding skinning weights to best approximate a sequence of deforming meshes. Our work is closely related to these approaches. We ï¬rst obtain a set of example deformations for the tetrahedral mesh by using physics-based simulation on a small number of artist-generated character poses. We then optimize for a sparse set of skinning weights that best explains the behavior of the internal vertices through the surface deformation. Other methods to compute skinning weights create a low-resolution cage from the surface mesh and compute, for each internal vertex, the harmonic [Joshi et al. 2007], mean-value [Ju et al. 2005] or Green coordinates [Lipman et al. 2008]. While these methods lead to smooth deformation ï¬elds, they are not without drawbacks. Besides the fact that an artist needs to model and rig the cage, harmonic coordinates are expensive to compute, mean-value coordinates can lead to non-conformal interpolation, and the geometry interpolated using Green coordinates is not guaranteed to remain inside the control cage, which, for our problem setting, would result in inverted tetrahedrons. In addition, the deformation ï¬elds generated with these methods are disconnected from the elastic model used to represent the characters. We therefore resort to an examplebased skinning method whose resulting deformation ï¬elds reï¬ect the nature of the underlying material.

3

Foundations

4

Efï¬cient Rig-Space Physics

The input to our method is a rigged character, which is deï¬ned by a surface mesh with ns vertices s = (s1 , . . . , sns )t and an abstract mapping p â s(p) (1) from a set of rig parameters p to corresponding deformed surface positions s(p). As a basis for simulating secondary motion in rig space, we assume that the character can be modeled as an elastic solid. We represent this solid by a volumetric mesh with ne tetrahedral elements and nv vertices, each of which carries a mass mi . The deformed and undeformed positions of the vertices are stored in vectors x â R3nv , respectively X â R3nv . We furthermore decompose the deformed positions into sets of ns surface vertices si whose positions are directly controlled by the rig, and ni internal vertices qi . The behavior of the solid is governed by an elastic energy W (X, x), whose precise form is deï¬ned by a deformation measure and a material law. Letting xe = (xe , . . . xe ) and Xe = 1 4 (Xe , . . . Xe ) denote the deformed, respectively undeformed posi1 4 tions of a given tetrahedral element, we compute its deformation gradient as F = dDâ1 , where d and D are (3Ã3) matrices whose columns hold deformed and undeformed edge vectors xe â xe , re1 i spectively Xe â Xe for 2 â¤ i â¤ 4. Using a modiï¬ed St. Venant1 i Kirchhoff material as described by Martin et al. [2011], the elastic energy density per element is obtained as W (x ) =
e e 1 Âµ||E||F 2

Our goal is to develop a formulation of rig-space physics that affords the same level of quality but is signiï¬cantly faster. We achieve this target by establishing a linearized formulation, eliminating the internal degrees of freedom using volumetric skinning, and using a deferred Jacobian evaluation.

4.1

Linear Rig Approximation

We start by linearizing the rig at the beginning of every time step as s(p) â s(pn ) + J(pn ) Â· (p â pn ) , (4)

âs where J = âp is the Jacobian of the rig. This simpliï¬cation is reminiscent of the semi-implicit Euler scheme described by Baraff and Witkin [1998], which relies on linearized forces. However, an important difference of our approach is that we linearize the rig but not the elastic forces and, as a result, the equations of motion remain nonlinear. Using nonlinear as opposed to linearized elastic forces leads to improved stability and requires only a few evaluations of elastic energy gradients and Hessians, which is signiï¬cantly faster than evaluating J. As a direct computational advantage of the rig linearization, we need to evaluate the Jacobian only once per time step and, moreover, second order derivatives of the rig vanish altogether.

4.2

Physics-based Volumetric Skinning

Ve +Î» 1â e V0

,

(2)

where || Â· ||F is the Frobenius norm, E = 1 (Ft F â I) is the Green 2 strain, V e and V0e are the deformed respectively undeformed volumes of the element, and Âµ, Î» are material parameters. The elastic energy of the entire solid is obtained by summing up elemental contributions as W = e W e Â· V0e . With the undeformed conï¬guration ï¬xed, the elastic energy is a function of only the deformed surface and internal vertices, W = W (s, q). Assuming that a subset ps of the rig parameters is scripted over time as part of an input animation, the goal is to automatically compute the motion of the remaining rig parameters. Adopting the implicit Euler method, Hahn et al. [2012] solve time-stepping by minimizing the nonlinear functional h2 t as Ms as + at Mq aq + W (s(p), q) H(p, q) = q 2 (3)

In the original rig-space physics method, the problem variables consist of the rig parameters and the position of the internal vertices. Besides the fact that the internal vertices contribute signiï¬cantly more degrees of freedom than the rig parameters (â 100 rig parameters vs. several thousand internal vertices), the internal vertices serve only a helper role in the computation of the internal energy for a given set of rig parameters. They are not visible in the resulting animation and of no interest to the artist. We would like to establish a formulation in which only the truly relevant variables, namely the rig parameters, are exposed as degrees of freedom. To this end, we start by assuming that the positions of the internal vertices are always deï¬ned by the boundary vertices through static equilibrium conditions: Ë q(p) = arg min W (s(p), q) .
Ë q

(5)

with respect to the free rig parameters pf and internal vertex positions q. In the above expression, Ms and Mq are diagonal mass matrices and the nodal accelerations are deï¬ned as as =
1 (s(p) h2

â 2sn + snâ1 ) ,

aq =

1 (q h2

â 2qn + qnâ1 ) ,

While this formula deï¬nes a unique mapping from rig parameters to internal vertices, the corresponding function is implicit: it requires minimizing the elastic energy and thus solving a set of nonlinear equations. Since doing so would be computationally expensive, our goal is to approximate this implicit nonlinear map by an explicit linear function. One option is to use cage-based deformation techniques such as Harmonic coordinates [Joshi et al. 2007] or Green coordinates [Lipman et al. 2008] that are used for deforming a high resolution embedded surface with an enveloping mesh. There are, however, two drawbacks with these approaches. First, an artist needs to design and rig a cage since there are no reliable automatic methods for this task. Second, while the deformation ï¬eld inside the cage is smooth, the corresponding vertex positions will generally be far from their equilibrium positions as dictated by the underlying elastic material. This disparity leads to an overestimation of the elastic energy and, in turn, severely affects the dynamics of the character. In contrast to typical cage-based modeling problems, we have explicit knowledge about how the internal deformation ï¬eld should

where the subscripts refers to the time step index. As demonstrated by Hahn et al. [2012], the above formulation affords high-quality simulations of secondary motion and other physics-based detail in rig-space. However, the resulting algorithm is computationally intensive for two primary reasons. First, minimizing (3) with a Newton-Raphson scheme requires ï¬rst and second derivatives of the rig s with respect to its parameters p. Since the rig is generally not available in analytic form, these derivatives have to be estimated using ï¬nite differences for each iteration of the solver. Second, the dimension of the resulting system is comparatively high, considering that only the free rig parameters are required. In the next section, we describe a method that greatly accelerates computations without compromising quality.

Figure 2: An impulse vector applied along the horizontal image axis results in a swinging motion for the elephantâs trunk, providing us with a sequence of surface deformations and corresponding internal deformations.

evolve as a function of the surface mesh. Namely, for every surface conï¬guration, we can compute the internal vertex positions by minimizing a nonlinear elastic energy. This observation motivates an example-based approach in order to compute an optimal linear approximation to the internal deformation ï¬eld. We ï¬rst describe how to generate a set of example poses and then explain how to compute the linear map.
Generating Example-Poses We assume that there is a small set of about ï¬ve to ten artist-generated poses that are representative of the typical range of motion during animation. In a production environment, such poses are typically created as a means of testing the character during the rigging stage and are referred to as calisthenics. Given these basic poses, we generate an augmented example set by applying a small number of impulse vectors to the surface of the character. Each of the impulse vectors deï¬nes initial velocities for the character that we use to perform a few steps of dynamic simulation by solving (3) for the free rig parameters as well as the corresponding equilibrium positions of the internal vertices. The result of this process, which we refer to as shaking, is a sequence of surface positions and corresponding internal deformation which we add to the example set. In this way, we can generate a wider range of poses that also reï¬ects the inï¬uence of the simulated rig parameters pf on the internal vertices (Fig. 2).

The formulation of system (6) is not yet practical. First, it allows weights to be negative, which, as reported by James and Twigg [2005], can lead to overï¬tting: large positive and negative weights can lead to a better ï¬t, but outside the training data, undesirable deformations occur. Second, it assumes dense correspondences since each internal vertex can potentially be inï¬uenced by every surface point. This property deteriorates run-time performance and, as shown in Sec. 5, we also found that dense correspondences give again rise to overï¬tting. A practical explanation for this undesirable behavior is that dense correspondences do not respect the inherent locality of the problem: the position of the internal vertices is directly inï¬uenced only by a certain neighbor set of close-by surface vertices. Despite this locality, the dense correspondence scheme can still use remote surface vertices in order to better explain the position of a given internal vertex if the training data so happens to support this prediction. However, remote correspondences do not generalize well to data outside the training set, resulting in the aforementioned overï¬tting. Ideally, we would like to choose the smallest set of close-by surface vertices that yields a robust ï¬t to the training data. Alas, automatically computing such a neighbor set is challenging. Thresholding based on Euclidean distance is difï¬cult to implement robustly since it is unclear how to choose the cutoff value. Internal vertices in some regions, such as the elephantâs belly, can be much further away from the surface than in other regions, like the arms. Our solution to this problem is to ask for a sparse set of correspondences that yields a ï¬t to the training data with a guaranteed upper-bound on the error. To this end, we augment system (6) with a sparse regularizer that penalizes the L1 norm of the weight vector as described in [Schmidt et al. 2007], thus favoring a sparse set of correspondences. In this way, we eliminate overï¬tting since only those vertices are used that are actually required to explain an internal vertexâs behavior. At the same time, we avoid the problem of having to heuristically determine the right sets of neighbors a priori. As another advantage, the signiï¬cantly reduced neighbor set also speeds up computations at run-time.
Sparse Correspondences

The shaking process provides us with a set of m deformed conï¬gurations xe = {se , qe }, comprising both surface and internal vertices that correspond to different poses of the character. For each internal vertex qj , we then seek to ï¬nd weights wj for the surface vertices that best explain the position of the internal vertex qe in the m different example poses, j
Example-Based Skinning

s1 1 ï£¯ . ï£¯ . wj = arg min ï£¯ . ï£°sm Ë wj 1 1 ï£®

Â·Â·Â· .. . Â·Â·Â· Â·Â·Â·

ï£¹ ï£® 1ï£¹ qj s1 n ï£¯ . ï£º . ï£º . ï£º . ï£º Â· wj â ï£¯ . ï£º Ë ï£¯ . ï£º ï£°qm ï£» sm ï£» n j 1 1

2

Algorithm 1 Finding a sparse correspondence set for skinning 1: for all internal vertices j do 2: (wj , r0 ) = solveNNLS(j, S0 ) 3: r = r0 , S = S0 4: while r < Î´ or r/r0 < 1.5 do Ë Ë 5: (S, wj ) = reduceCorrespondenceSet(S, wj ) Ë 6: S=S Ë 7: (wj , r) = solveL1(j, S, wj ) 8: end while 9: (wj , rf ) = solveNNLS(j, S) 10: end for Our method for computing sparse weights is described in Algorithm 1. Starting from a conservative (or even full) set of correspondences S0 , we ï¬rst determine the initial error r0 of the ï¬t by solving system (6) subject to positivity constraints for the weights using a non-negative least squares solver (line 2) as described in [James and Twigg 2005]. We then iteratively solve the L1 -regularized version of (6) using Newtonâs method (line 7) and remove the surface vertices with the smallest weights from the correspondence set (line 5). The iteration is stopped whenever removing an additional vertex would lead to a residual error larger than a given threshold value Î´. We recompute the ï¬nal weights by solving system (6) again without the L1 -regularizer (line 9). The result of our sparse algorithm is small sets of surface vertices and corresponding weights that explain the behavior of the internal

.

(6)

In the above system, each row stands for three equations (x,y, and z-components), while the last row asks that weights sum to one, which ensures that the internal vertices transform correctly under rigid transformations of the surface. After solving the above problem for every vertex, we obtain a linear map between surface and internal vertices, q(s) = Ws, where W = [w1 , w1 , w1 , . . . , wnq , wnq , wnq ]t is the skinning matrix. Due to its similarity to linear blend skinning, we refer to this map as physics-based volumetric skinning.

vertices in a robust and efï¬cient way. As we show in Sec. 5, using sparse correspondences improves both the computational efï¬ciency at run time and eliminates overï¬tting.

4.3

Deferred Jacobian Evaluation

Even when keeping the Jacobian constant per time step, its evaluation still constitutes a major part of the total computation time. Yet, due to the inherent temporal coherence in animations, the Jacobian often does not change signiï¬cantly from one time step to the next. Ideally, we would like to recompute the Jacobian only when necessary. While it is, to some extent, acceptable to trade accuracy for performance, we cannot compromise on stability. We therefore need a robust indicator for evaluating the error incurred by keeping the same Jacobian over multiple time steps. In order to quantify the error of the current approximation, we compare the end-of-time-step positions Ë = s(pn ) + Jâp predicted by s the linear approximation to the actual positions s(pn + âp). A natural metric for this difference is the kinetic energy due to the difference in position over the time step h, âEkin =
1 (Ë s 2h

Figure 3: A visual comparison between rig-space physics [Hahn et al. 2012] and our method for a selected frame. The average/maximum vertex error is below 0.08%/1.4% for all frames.

5

Results and Discussion

â s(pn + âp))t Ms (Ë â s(pn + âp)) . s

(7)

Computing this indicator requires only one rig evaluation, but it provides us with valuable information about the linearity of the rig around the current set of parameters and in the direction of the characterâs motion. Taking an optimistic approach, we can always reuse the existing Jacobian to step the rig parameters forward in time. We then evaluate the indicator and, if it signals too high a degree of nonlinearity, we roll-back to the beginning of the step, compute the Jacobian J(pn ), and simulate again. While this approach is always robust and efï¬cient in many cases, animations with rapid motion and extreme deformations can lead to an excessive number of rollbacks, effectively undoing the advantage of deferred Jacobian evaluation. In order to decrease the number of such roll-backs, we use an additional indicator that estimates the linearity of the rig (in the relevant direction) without requiring a full simulation step: instead of solving for âp ï¬rst, we simply estimate the end-of-time-step Ë parameters p using an extrapolation of past states as
1 Ë p = pn + h (pn â pnâ1 ) .

In this section, we present results of our method and compare its performance to previous work. We also validate the physics-based skinning method by comparing it to a state-of-the-art alternative approach. For a fair comparison with rig-space physics [Hahn et al. 2012], we apply our method to the elephant walk cycle animation from the original work, using the same parameter values as reported in the corresponding paper. To be consistent with [Hahn et al. 2012], we simulate the trunk and the belly of the elephant separately, which are controlled through 13 (trunk) and respectively 36 (belly) rig parameters. Taking the animation produced by rig-space physics as the ground truth, we compare the simulation time as well as the difference in geometric deformation to our method using several different options. The results of these comparisons are summarized in Table 1 and a visual comparison for an exemplary frame is shown in Fig. 3. As can be seen from these data, our linearized formulation (row 2) is already signiï¬cantly faster than the reference method (row 1). Yet, our physics-based volumetric skinning and its associated dimension reduction achieves another drastic speedup. We point out that, despite these signiï¬cant accelerations, the quality of the animation remains the same: visually, the differences between the original method and our approach are imperceptible, as the average/maximum difference in vertex position for the belly is below 0.08%/1.4% of the characterâs height for all frames. Table 1 also indicates that our deferred Jacobian evaluation scheme (rows 4 and 5) is very effective for the belly of the elephant, whereas there is no speedup for the trunk. This result occurs because the rig is mostly linear in the region of the belly and our method can thus leverage the full potential of deferred Jacobian evaluation. For the trunk, however, the rig is based on a nonlinear wire deformer and its Jacobian changes signiï¬cantly in virtually every step of the animation. Deferred Jacobian evaluation is therefore not helpful for this example, but our linearity predicator is able to detect the nonlinearity of the rig and triggers Jacobian updates for 280 out of 360 frames. In contrast, when simulating the trunk with deferred Jacobian updates but without the predictor, 281 frames had to be resimulated, resulting in a severe performance penalty. Our second example is an animation of a sumo wrestler, Sumone, performing a characteristic foot stomp followed by vigorous head shaking. In addition to the usual pose controls, this character also has a total of 174 rig parameter for secondary motion, all of which we simulate using our method. An exemplary frame of this ani-

As shown in Sec. 5, this indicator leads to signiï¬cantly fewer rollbacks while limiting the number of Jacobian reevaluations.

4.4

Implementation

With our physics-based skinning method, the functional (3) now only depends on the free rig parameters: H = H(p). We perform time-stepping by minimizing H(p) using Newtonâs method, which requires the gradient and Hessian of H. For convenience, we include the relevant formulas here. We emphasize again that, while each iteration requires the reevaluation of the elastic energy gradient and Hessian, the rig Jacobian stays constant. The gradient of H is obtained as âW âW â H(p) = Jt Ms as + + Wt Mq aq + âp âs âq and the Hessian follows as â 2 H(p) = Jt âp2 1 â2W Ms + + Wt h2 âs2 1 â2W Mq + h2 âq2 W J ,

+Jt Wt

â2W â2W + W J. âqâs âsâq

Figure 4: An exemplary frame from an input animation without secondary motion (left), and with secondary motion for belly, chest, hair, and cheeks simulated using our method (right).

Figure 5: Elastic energy plots for 64 frames of the elephant belly animation using static solve (blue), NNLS with 500 correspondences (red), NNLS with 20 correspondences (purple), and our physics-based skinning (green). Solver Trunk tframe 7.24 0.37 0.39 0.12 0.13 Belly tframe 46.5 0.53 0.39 0.27 0.13 Sumone tframe â 2.82 2.48 1.04 0.58

mation is shown in Fig. 4, but the results are best viewed in the accompanying video, in which it can be seen that our method achieves lively and organic-looking motion for the characterâs belly, chest, cheeks, and hair. On the performance side, simulating this large number of parameters with rig-space physics is out of reach, whereas our method takes less than one second per animation frame. The timings for this animation are also listed in Table 1. Similar to the ï¬rst example, our physics-based skinning offers a signiï¬cant speedup, as does the deferred Jacobian evaluation.
Skinning In order to analyze the efï¬ciency of our skinning method, we compared it to the non-negative least squares (NNLS) solver described by James and Twigg [2005]. We quantify the performance of these approaches by plotting the resulting elastic energy for the individual frames of the elephant belly animation as shown in Fig. 5.

RSP IV1, JE1 IV1, JE2 IV2, JE1 IV2, JE2

sp Ã1 Ã19 Ã18 Ã56 Ã53

sp Ã1 Ã86 Ã118 Ã168 Ã348

sp â Ã1.0 Ã1.1 Ã2.7 Ã4.9

Table 1: Timings for the elephant walk cycle (Trunk, Belly) and the Sumone animation on an Intel Core i7-930 4 x 2.8Ghz using per-frame (JE1) and deferred (JE2) Jacobian evaluation, as well as static solves (IV1) and skinning (IV2) for the internal vertices. tframe is computation time per frame in sec., and sp is the speedup.

vertex for the trunk/belly, respectively. The Sumone mesh consists of 967 interior and 1302 surface vertices and we used 77 poses for skinning. The initial correspondence set of 20 surface vertices per internal vertex was reduced to 6.87 on average in 16.5s (per vertex).

We start by using the NNLS scheme on a large set of 500 closest surface vertices for each internal vertex. We measure the distance between internal and surface vertices in a geodesic sense by marching along the volume mesh. In this way, we ensure that a surface vertex on the belly is not erroneously quantiï¬ed as close to an internal vertex of an arm. As can be seen from Fig. 5, the elastic energy obtained with NNLS weights on this large correspondence set (red curve) is signiï¬cantly higher than the ground truth (blue curve), except for the regions around the three frames which were part of the training set. Moreover, the ground truth shows a regular saw-tooth pattern, but the NNLS solution exhibits two pronounced spikes where the elastic energy is approximately ï¬ve times higher than the reference value. Reducing the per-vertex correspondence set to the 20 closest surface vertices even leads to slightly worse behavior (purple curve). However, starting from the same 20 correspondences per internal vertex, our physics-based skinning method is not only able to reduce the average number of correspondences to 5.56, it also leads to a much closer tracking of the reference data. This behavior can be explained by the fact that our sparsity-based weight computation scheme only keeps correspondences that are actually required, thus eliminating overï¬tting. As a ï¬nal comparison, using NNLS with only the 5 closest surface vertices leads to unusable behavior. In our system, the skinning weights have to be computed only once in a preprocessing step. For the elephant mesh (1328 interior and 761 surface vertices), we used 74 poses as training data for the skinning. The initial correspondence sets of 20 surface vertices per internal vertex was reduced to an average of 5.52/5.55 in 30s/29s per

6

Conclusion

We presented an efï¬cient method to augment artist-generated keyframe animations with physically-simulated secondary motion. Our method is signiï¬cantly faster than the reference solution by Hahn et al [2012], but it provides the same quality and inherits all of its beneï¬ts. The robustness and performance of our method are grounded on a linearized formulation of rig-space physics, a physics-based volumetric skinning method, as well as a deferred Jacobian evaluation scheme. Editing the material stiffness for individual rig parameters is not currently supported by our method. As a related challenge, it can be cumbersome to ï¬nd material parameters that yield soft behavior around the rest state but do not lead to excessive deformations for fast motion. A promising direction for future work involves investigating the intuitive design and art direction of such materials. In this endeavor, our method could provide quick feedback on the outcome.
Limitations and Future Work

For the examples show in this paper, we used a constant time step size 0.01s, which is a fraction of the upper bound as dictated by the number of frames per second. But while parts of an animation might actually admit this maximum step size, sequences with rapid motion and large deformations will typically require smaller steps in order to maintain stability. An adaptive time stepping scheme could exploit this fact, thereby increasing robustness and efï¬ciency.

Our system currently uses a single rest state mesh and extreme character poses can potentially lead to very distorted or even inverted elements. An interesting avenue for future work would be to investigate remeshing approaches or even meshless discretizations. Our method seems to invite such adaptive approaches since it uses only the free rig parameters as real degrees of freedom, making adaptations to the underlying mesh a lightweight process.

J U , T., S CHAEFER , S., AND WARREN , J. 2005. Mean value coordinates for closed triangular meshes. In Proc. of ACM SIGGRAPH â05. K AVAN , L., AND S ORKINE , O. 2012. Elasticity-inspired deformers for character articulation. In Proc. of ACM SIGGRAPH Asia â12. ËÂ´ K AVAN , L., C OLLINS , S., Z ARA , J., AND OâS ULLIVAN , C. 2008. Geometric skinning with approximate dual quaternion blending. K AVAN , L., S LOAN , P.-P., AND OâS ULLIVAN , C. 2010. Fast and efï¬cient skinning of animated meshes. In Proc. of Eurographics â10. K RY, P. G., JAMES , D. L., AND PAI , D. K. 2002. Eigenskin: real time large deformation character skinning in hardware. In Proc. of Symp. on Computer Animation â02. L E , B. H., AND D ENG , Z. 2012. Smooth skinning decomposition with rigid bones. In Proc. of ACM SIGGRAPH Asia â12. L EWIS , J. P., C ORDNER , M., AND F ONG , N. 2000. Pose space deformation: a uniï¬ed approach to shape interpolation and skeleton-driven deformation. In Proc. of ACM SIGGRAPH â00. L IPMAN , Y., L EVIN , D., AND C OHEN -O R , D. 2008. Green coordinates. In Proc. of ACM SIGGRAPH â08. ` M AGNENAT-T HALMANN , N., L APERRI E RE , R., AND T HAL MANN , D. 1989. Joint-dependent local deformations for hand animation and object grasping. In Proc. of Graphics Interface â88. M ARTIN , S., T HOMASZEWSKI , B., G RINSPUN , E., AND G ROSS , M. 2011. Example-based elastic materials. In Proc. of ACM SIGGRAPH â11. M C L AUGHLIN , T., C UTLER , L., AND C OLEMAN , D. 2011. Character rigging, deformations, and simulations in ï¬lm and game production. In ACM SIGGRAPH 2011 Courses. N EALEN , A., M LLER , M., K EISER , R., B OXERMAN , E., AND C ARLSON , M. 2006. Physically based deformable models in computer graphics. Computer Graphics Forum 25, 4, 809â836. S CHMIDT, M. W., F UNG , G., AND ROSALES , R. 2007. Fast optimization methods for l1 regularization: A comparative study and two new approaches. In ECML â07, 286â297. S INGH , K., AND F IUME , E. L. 1998. Wires: A geometric deformation technique. In Proc. of ACM SIGGRAPH â98. S LOAN , P.-P. J., ROSE , III, C. F., AND C OHEN , M. F. 2001. Shape by example. In Proc. of Symp. on Interactive 3D Graphics â01. T ERZOPOULOS , D., P LATT, J., BARR , A., AND F LEISCHER , K. 1987. Elastically deformable models. In Proc. of ACM SIGGRAPH â87. WANG , X. C., AND P HILLIPS , C. 2002. Multi-weight enveloping: least-squares approximation techniques for skin animation. In Proc. of Symp. on Computer Animation â02.

Acknowledgements
We would like to thank the anonymous reviewers for their useful comments and suggestions. Many thanks to Maurizio Nitti for creating the Sumone character.

References
BARAFF , D., AND W ITKIN , A. 1998. Large steps in cloth simulation. In Proc. of ACM SIGGRAPH â98. Â´ BARAN , I., AND P OPOVI C , J. 2007. Automatic rigging and animation of 3d characters. In Proc. of ACM SIGGRAPH Asia â07. Ë Â´ BARBI C , J., DA S ILVA , M., AND P OPOVI C , J. 2009. Deformable object animation using reduced optimal control. In Proc. of ACM SIGGRAPH â09. FALOUTSOS , P., VAN DE PANNE , M., AND T ERZOPOULOS , D. 1997. Dynamic free-form deformations for animation synthesis. IEEE Trans. on Visualization and Computer Graphics 3, 3. G ILLES , B., B OUSQUET, G., FAURE , F., AND PAI , D. 2011. Frame-based elastic models. ACM Trans. on Graphics 30, 2. Â¨ G RINSPUN , E., H IRANI , A. N., D ESBRUN , M., AND S CHR ODER , P. 2003. Discrete shells. In Proc. of Symp. on Computer Animationâ03. H AHN , F., M ARTIN , S., T HOMASZEWSKI , B., S UMNER , R., C OROS , S., AND G ROSS , M. 2012. Rig-space physics. In Proc. of ACM SIGGRAPH â12. Â¨ H ASLER , N., T HORM AHLEN , T., ROSENHAHN , B., AND S EIDEL , H.-P. 2010. Learning skeletons for shape and pose. In Proc. of Symp. on Interactive 3D Graphics â10. I RVING , G., T ERAN , J., AND F EDKIW, R. 2004. Invertible ï¬nite elements for robust simulation of large deformation. In Proc. of Symp. on Computer Animation â04. JACOBSON , A., AND S ORKINE , O. 2011. Stretchable and twistable bones for skeletal shape deformation. In Proc. of ACM SIGGRAPH Asia â11. Â´ JACOBSON , A., BARAN , I., K AVAN , L., P OPOVI C , J., AND S ORKINE , O. 2012. Fast automatic skinning transformations. JAMES , D. L., AND FATAHALIAN , K. 2003. Precomputing interactive dynamic deformable scenes. In Proc. of ACM SIGGRAPH â03. JAMES , D. L., AND PAI , D. K. 1999. Artdefo: accurate real time deformable objects. In Proc. of ACM SIGGRAPH â99. JAMES , D. L., AND T WIGG , C. D. 2005. Skinning mesh animations. In Proc. of ACM SIGGRAPH â05. J OSHI , P., M EYER , M., D E ROSE , T., G REEN , B., AND S ANOCKI , T. 2007. Harmonic coordinates for character articulation. In Proc. of ACM SIGGRAPH â07.

