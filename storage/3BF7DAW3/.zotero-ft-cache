Chopper: Partitioning Models into 3D-Printable Parts
1 Princeton

Linjie Luo1,2 Ilya Baran3 Szymon Rusinkiewicz1 Wojciech Matusik4 2 Disney Research 3 Disney Research Zurich 4 MIT CSAIL University

Figure 1: Chopper partitions a given 3D model into parts that are small enough to be 3D-printed and assembled into the original model. Left to right: the input chair model, Chopperâs partition (with a printing volume shown as a reference), printed parts, and assembled chair.

Abstract
3D printing technology is rapidly maturing and becoming ubiquitous. One of the remaining obstacles to wide-scale adoption is that the object to be printed must ï¬t into the working volume of the 3D printer. We propose a framework, called Chopper, to decompose a large 3D object into smaller parts so that each part ï¬ts into the printing volume. These parts can then be assembled to form the original object. We formulate a number of desirable criteria for the partition, including assemblability, having few components, unobtrusiveness of the seams, and structural soundness. Chopper optimizes these criteria and generates a partition either automatically or with user guidance. Our prototype outputs the ï¬nal decomposed parts with customized connectors on the interfaces. We demonstrate the effectiveness of Chopper on a variety of non-trivial real-world objects. CR Categories: I.3.5 [Computer Graphics]: Computational Geometry and Object ModelingâGeometric Algorithms; Keywords: 3D printing, mesh segmentation and decomposition Links: DL PDF

parts and assembled. Existing commercial systems rely on manual partitioning, but this can be tedious if many parts are needed. Recent work in the ï¬eld of computer graphics, however, has investigated computation-assisted fabrication approaches in which the user speciï¬es the desired visual or physical properties of an object to be manufactured, and an optimization is used to determine the precise way in which fabrication devices should be driven to produce an object as close as possible to the goal. The optimization may be formulated to consider visual properties such as scattering [HaÅ¡an et al. 2010] or physical properties such as deformation [Bickel et al. 2010], but in this paper we focus purely on 3D shape. We propose that this kind of optimization approach may be applied to the problem of decomposition into print volumes, yielding an automated method that is quicker, easier, and in many instances better than can be accomplished by hand. This work presents a framework, called Chopper, for partitioning objects for 3D printing. Because the number of ways in which an object may be partitioned is large, we seek to ï¬nd a decomposition that optimizes a number of (sometimes conï¬icting) objectives: â¢ Printability: the parts must ï¬t inside the working volume. â¢ Assemblability: it must be possible to put parts together (without interference) into a ï¬nished model. â¢ Efï¬ciency: the partition should avoid small parts and, in general, minimize the number of required sub-volumes. â¢ Connector feasibility: each interface must be large enough to admit connectors, protrusions, or other aids to assembly. â¢ Structural soundness: parts should not have thin slivers, and seams should be away from areas of high mechanical stress. â¢ Aesthetics: seams should be unobtrusive, detracting from appearance as little as possible, and should follow the natural symmetries of the model. Formalizing these objectives is not easy, since different use cases have different requirements. Moreover, it is easy to propose deï¬nitions for the objective functions that lead to sub-optimal partitions or interact in unwanted ways. We propose speciï¬c deï¬nitions (Sec-

1

Introduction

As 3D printing technology matures, becoming cheaper and simpler to use, printing ever-larger objects becomes feasible. At the same time, the maximum size of an object that a 3D printer can produce in one pass (the printing volume) is limited by practical considerations. Larger objects must therefore be printed as separate

tion 3.2) and weightings between different objectives (Section 4) that, based on our testing, typically lead to high-quality results. Designing a Framework for Optimization: A natural approach to creating printable partitions is to treat this as a covering problem: the object must be completely covered by print volumes. This, however, quickly leads to problems with efï¬ciency and solvability. For example, consider just minimizing the number of parts, under extremely restrictive assumptions: in 2D, if the printing volume is a unit square, it is an open problem whether a square of side length 2.01 can be printed as 6 parts, or if 7 are necessary [Soifer 2006; Januszewski 2009]. Even given a feasible covering, it is difï¬cult to go from this to a concrete set of cuts, which we must do to evaluate some of the objective functions (such as connector feasibility and seam aesthetics). Finding a set of cuts leading to an assemblable partition is difï¬cult (since these cuts may have to be non-planar) and impractical to do every time we evaluate a coveringâs quality. Chopper is therefore built upon an alternative approach: searching top-down for a binary tree representing the assembly sequence in which two parts are joined at each step. More speciï¬cally, we restrict ourselves to planar cuts between any two joined parts, yielding a Binary Space Partitioning or BSP tree [Fuchs et al. 1980]. This is an important design decision, since by giving up the ï¬exibility of arbitrary cuts we gain efï¬ciency. Also BSPs provide a natural recursive framework for optimizing over the objectives, and in fact satisfy two objectives by construction (printability â by recursing down until each part ï¬ts inside the working volume â and assemblability â by reversing the order of the cutting recursion and the convexity of each BSP partition). The search for the best BSP tree can proceed greedily, with the best single plane chosen at each level of recursion, or may consider alternatives that are not necessarily locally optimal in the hope that they lead to a better overall solution. Because of the size of the search space, it is impossible to enumerate all possible partitions exhaustively. We therefore adopt beam search [Lowerre 1976], which maintains a set of the b best partitions at each stage of the algorithm. Each step of the search considers all ways of augmenting each existing partition with an additional cut, evaluates the objective functions, and keeps the b best resulting partitions. The search terminates once all parts ï¬t within the working volume. We show that even a relatively small beam width results in modest improvements over greedy search, at the cost of increased running time (by a factor of b). In constrast, we ï¬nd that depth-ï¬rst search with backtracking did not lead to better results than greedy search.

Figure 2: An illustration of a 3D object partitioned by a BSP tree into six parts. Left: the partitioned parts and the BSP tree. Planes are denoted as squares and parts as circles with corresponding colors. Middle: planes in the BSP tree, with colors corresponding to interior nodes (squares) in the tree at left. Right: cross sections of the planes and the object. Note that the cross-sections may have multiple connected components, e.g., on the red plane. in general [Lau et al. 2011], buildings [Whiting et al. 2009], garments [Umetani et al. 2011], Burr puzzles [Xin et al. 2011], planar sections [McCrae et al. 2011; Hildebrand et al. 2012], etc. Recently, Stava et al. [2012] proposed a tool that performs a structural analysis on a 3D model and then corrects the model using hollowing, thickening, and strut insertion. Our work falls broadly into this category of research, and uses a similar constrained optimization framework to many of these approaches, though the details are speciï¬c to our application. The assembly of objects from parts has also been investigated [Agrawala et al. 2003]. Several methods focus on determining the optimal 3D orientation at which a single part should be printed [Alexander et al. 1998; Thrimurthulu et al. 2004], considering factors such as support material cost, printing time, and surface roughness. Research has also focused on techniques for packing multiple parts into the printing volume [Ikonen et al. 1998; Dickinson and Knopf 1998; Egeblad et al. 2009]. An automatic curvature-based method for partitioning models for 3D printing has been recently proposed [Hao et al. 2011]. This method makes strong assumptions that make it suitable for only a small class of models. Among its limitations are: â¢ It assumes that potential cuts are restricted to planar sharp or ï¬lleted features in the model. â¢ To detect these features, it relies on properties of the triangulation such as dihedral angles and perimeter ratios of adjacent triangles. â¢ Because the method may choose a partial planar cut, there is no guarantee that the resulting parts can be assembled or even that the cut actually partitions the model into two. â¢ The method does not consider printing parts in different orientations to make better use of the print volume. In our dataset, only the bearing model has the properties needed to be successfully processed by the algorithm of Hao et al. To our knowledge, the only other automatic methods for partitioning models for 3D printing are based on partitions on a regular grid [Medellin et al. 2007]. This is a greatly reduced space of possible partitions that are likely to use too many cuts, ignore object features, and make poor use of the printing volume.

2

Related Work

Partitioning models has been studied in different contexts outside rapid prototyping, therefore ignoring the concerns speciï¬c to 3D printing (part size, assemblability, etc.) on which we focus. For example, decomposing polyhedra into convex parts [Chazelle 1981] â even approximately [Lien and Amato 2007] â is a wellknown challenging problem in computational geometry. Generating a volumetric mesh of limited-size tetrahedra (e.g., via constrained Delaunay tetrahedralization [Shewchuk 1998]) is a vital preprocess for physical simulation. Mesh segmentation [Shamir 2008; Chen et al. 2009; Attene et al. 2006] typically focuses on decomposing the surface of an object into semantically meaningful parts, using heuristics based on geometric properties such as curvature and shape diameter. Our work shares a few objectives with these techniques (e.g., minimizing seam length). A number of design tools focus on creating physical objects using a variety of fabrication techniques. These objects include plush toys [Mori and Igarashi 2007], chairs [Saul et al. 2011], furniture

3

Approach

For a user-provided model, Chopper employs beam search (Section 3.1) to ï¬nd a BSP tree that partitions the model into a number of

parts, guided by the objective functions that evaluate various aspects of the BSP, e.g., the number of parts, seam length, symmetry (Section 3.2). Each plane of the BSP tree forms a cut. (Note that each part is not necessarily a single connected component.) The cross-section of a cut is the polygon set that is the intersection of the object interior and the portion of the cut plane inside its BSP region. This polygon set may comprise multiple disjoint polygons, which may contain holes, and deï¬nes the connected components of the cut. Figure 2 illustrates these concepts. Each part partitioned by the output BSP tree should ï¬t into the printing volume of the target 3D printing device. Low-cost printers may have a printing volume as small as 10 cm Ã10 cm Ã10 cm, while higher-end devices may go up to 50 cm Ã 40 cm Ã20 cm. Chopper places connectors, according to a user-provided pattern, on every cross-section (Section 3.3). Depending on their design, the connectors may provide sufï¬cient structural strength to hold parts together, or may merely serve as guides for assembly, with glue used to permanently attach parts. In our experiments we use connectors in the shape of pentagonal prisms, providing a sturdy connection that prevents parts from rotating.
3.1 Search Framework

Evaluating Candidate Cuts: Given a partial BSP, we consider all ways of augmenting it by cutting the largest part â i.e., the part with the largest number-of-subvolumes estimate (Section 3.2.1). In addition to making progress towards the ultimate goal, we ï¬nd that evaluating the largest parts ï¬rst improves our estimate of the quality of a BSP tree: the biggest parts are usually the ones with the greatest overestimations in the objective functions. We consider cutting the part with all possible planes Ïi j = (ni , d j ), where ni and d j are plane normals and offsets, respectively (and the plane is deï¬ned by ni Â· x â d j = 0). To ensure uniform sampling, we take our set of plane normals N = {ni } to be the vertices of a thrice-subdivided regular octahedron. This results in 129 uniformly distributed directions and proves to be a good tradeoff between result quality and running time. (Only one of each pair of opposite directions is taken.) We augment the set of candidate normals with N , the axes of each partâs minimum oriented bounding box, in order to provide additional opportunities for selecting an aesthetically-pleasing cut. The plane offsets {d j } are sampled uniformly (at intervals of 0.5 cm in our examples) over the range for which the planes intersect the object, for each ni . We observe that evaluating the objective functions for each candidate cut is naturally organized as a set of nested loops (per-cutplane-orientation, per-cut-plane-position, per-objective). In order to minimize computation time, Chopper pushes as much computation as possible into the outer loops. In addition, we exchange the two innermost loops relative to their natural order, evaluating each objective on a batch of parallel planar cuts (i.e., looping over objectives outside the loop over plane positions). This batching provides optimization opportunities for most objectives. For example, computing the cross-sections for k single planes independently takes O(kn + c) time (where n is the number of mesh vertices and c is the total size of all the cross-sections), but doing this computation batched takes O(k + n + c) time. Selecting Cuts: After evaluating all the candidate augmented BSPs, we would ideally like to retain the b best ones. However, for relatively small (hence practical) values of b, there is a danger of degrading the diversity of the selection if too many similar BSPs are selected. Therefore, the new BSPs resulting from each parent are ï¬rst pruned by sorting the planes according to their objective scores, then walking along this list from lowest to highest. BSP trees that are sufï¬ciently close (in RMS distance) to already-selected ones are discarded â a typical value for the threshold is 0.1 of the diagonal of the printing volume. The surviving trees resulting from all parents are combined, and the b best ones are kept. Termination: The search terminates when all BSPs in the beam reach their goal states, which are decompositions in which all parts ï¬t into the target printing volume. The best BSP, as evaluated by the objective functions, is returned as the ï¬nal solution. As a postprocess, Chopper places connectors on the cross-sections so that they do not interfere with each other (Section 3.3).
3.2 Objective Functions

Algorithm 1: Chopper search input : O is the object, b is beam width output : T is the BSP tree that partitions the object function T = B EAM S EARCH (O, b) currentBSPs â â while not A LL AT G OAL (currentBSPs) newBSPs â â foreach T â N OTAT G OAL S ET (currentBSPs) currentBSPs â= T P â L ARGEST PART (O, T ) newBSPs += E VAL C UTS (T , P) while |currentBSPs| < b currentBSPs += H IGHEST R ANKED (newBSPs) return H IGHEST R ANKED (currentBSPs) function ResultSet = E VAL C UTS (T , P) N â U NIFORM N ORMALS () N â AUXILIARY N ORMALS (P) parallel foreach ni â N âª N foreach objective function fk foreach plane Ïi j = (ni , d j ) intersecting P T â A DD T O BSP(T , Ïi j ) f (T ) += Î±k fk (T ) ResultSet â â foreach T sorted by f (T ) if S UFFICIENTLY D IFFERENT (T , ResultSet) ResultSet += T return ResultSet

Chopper uses beam search to partition the model (Algorithm 1). The algorithm begins with an empty BSP, and at each step it selects the most promising BSPs from the previous step to extend with an additional cut. The maximum number of BSPs selected at each step is the beam width: it determines the breadth that the algorithm explores into the combinatorial search space. All results in this paper use a beam width of b = 4, unless otherwise stated.

Given a set of candidate BSPs, we evaluate a set of objective functions that rank these BSPs in terms of the number of resulting parts, connector feasibility, structural soundness, and seam unobtrusiveness. The ï¬nal score is computed as a linear combination of the separate scores of all objective functions of a BSP T : f (T ) = â Î±k fk (T ).
k

(1)

The details of the objective functions will be discussed in the following subsections. We motivate each objective by demonstrating a result obtained when that objective is not used. The objectives

are all unitless so that a single set of weights can work with a large range of objects. Note that due to the nature of the beam search algorithm (Section 3.1), the BSPs being evaluated are all extended from existing ones, which enables fast accumulative computation of most of the objective functions from the previous results. An objective function may return inï¬nity if the cut is completely infeasible according to that objective. In that case, subsequent objective function evaluations are skipped for that cut.
3.2.1 Number of Parts

Figure 4: Without the utilization objective (left), Chopper produces a small part for this rocker arm (yellow). The utilization objective forces larger parts and results in one fewer cut (right). During the execution of Algorithm 1, we maintain a point set of potential (female) connector locations on both sides of every cut, initially sampled from the cross-section with a uniform grid (see Figure 13, left). When choosing a new cut, we must consider the quality of both the connector locations on the new cut and connectors on previously chosen cuts, some of which may intersect the new cut (Figure 6). Evaluating the robustness of a potential connector placement is intractable for the large number of candidates we wish to process, so we approach the problem analogously to computing a support polygon in rigid-body mechanics. We use the convex hull of the potential connector locations as a measure of the quality of a potential connector placement on a connected component G of a crosssection C. Intuitively, a large convex hull makes it less likely that a large torque will be applied. We compute the area aG of this convex hull, offset outwards by the connector radius. We also compute the area AG of the relevant connected component of the cross-section. The connector feasibility objective is then deï¬ned as fconnector (T ) = max max AG /aG â Tc , 0 , (4)

Estimating the minimum number of boxes (assuming that a print volume is a box) to cover an arbitrary object is NP-hard even in 2D and disallowing rotations [Aupperle et al. 1988]. We do not attempt to ï¬nd the minimum number, but we do need to guarantee that eventually the algorithm will terminate. To this end, we estimate an upper bound, Î(P), on the number of parts for P neglecting all other objectives. As this bound, we use the number of print volumes that (in a regular grid) tile the minimum Oriented Bounding Box (OBB) of P. The minimum OBB is computed approximately by iteratively optimizing two axes at a time using rotating calipers [Toussaint 1983] or gets its orientation from the parent part, whichever leads to a smaller Î (breaking ties by volume). Given a BSP T , we would like to minimize Î(P) on all parts P in T : (Figure 3): 1 fpart (T ) = (2) â Î(P), Î0 PâT where Î0 is the upper bound estimate of the initial input model. Because the granularity of fpart is entire working volumes, we wish to add a ï¬ner-level distinction to penalize parts that do not use the print volume efï¬ciently (Figure 4). Let VP be the volume of a part P in T and let V be the printing volume. Then we compute a utilization objective: VP . (3) futil (T ) = max 1 â PâT Î(P)V
3.2.2 Connector Feasibility

GâCâT

which is appropriately inï¬nity if some connected component has no feasible connector locations and therefore aG = 0. We clamp AG /aG to Tc = 10 from below to avoid this objectiveâs having an undesirably large inï¬uence on cuts with sufï¬ciently good connector placement potential. To determine if the female connector ï¬ts at a location in the volume, we approximate its geometry conservatively as a union of a few spheres. We also maintain a distance ï¬eld inside the object. We sample the distance ï¬eld at the locations of potential sphere centers and compare the distances to the sphere radii to determine if the connector ï¬ts. In this phase, we ignore the possibility that two female connectors from different cross-sections may overlap; we

We force each connected component of the cross-section of each cut to have one or more connectors to ensure the object does not fall apart. While this condition is not strictly necessary (a donut cut in half needs only one connector for the two connected components of the cross-section), we found that it helps the structural soundness of the part without being overly restrictive. A single connector on a large cross-section, however, may not be desirable: allowing for several connectors results in a more robust connection. Moreover, several connectors in a straight line are not as robust as the same number of connectors spread out in 2D. Therefore, we formulate an objective that seeks to ï¬nd cuts maximizing the potential quality of connector placement (Figure 5).

Figure 3: Without the number-of-parts objective, Chopper chooses a partition (left) with more cuts than necessary (right).

Figure 5: Without considering connector feasibility (left), Chopper selects a cutting plane that results in cross-sections too small to install connectors (between the hands and heads). The connector feasibility objective ensures each connected component of the cross sections is sufï¬cient for connector placement (right).

1 3

1 3 4

2

2

Figure 6: Left: An object with three cuts and potential female connector locations (green) on the cross-sections. Right: when a new cut is introduced, some of the connector locations become invalidated (red) due to intersection. resolve such conï¬icts when we actually place the connectors (after the BSP tree has been completely generated â see Section 3.3). Chopper can support a number of possible connector designs. We have considered connectors that snap together, require screws, or even glue. For our experiments, we simply use pentagonal prisms, with a male prism extruding from the surface of one part and ï¬tting into a female prism on another part. Supporting glue would be strictly easier, requiring no modiï¬cations to geometry.
3.2.3 Structural Soundness

Fragility: Even if cuts do not pass through high-stress areas of the original model, the resulting parts may still be fragile due to thin ï¬ns or bridges that connect two larger parts (Figure 8). We assume that the initial object is structurally sound and try to avoid creating structures that introduce fragility. The necessary condition for this structure to result from a cut is the existence of one point on the structure whose tangential plane is nearly parallel to the cut plane Ï and whose distance to Ï is sufï¬ciently small. To eliminate these cases, we identify the set S of vertices on the part surface that satisfy at least one of two conditions. The ï¬rst condition is that the vertex normal n p is sufï¬ciently parallel to the cut planeâs normal n: i.e., n p Â· n > Tn , where we use Tn = 0.95. To evaluate the second condition (primarily for parts with bad normals), we check which one-ring edges point away from the normal and which point towards the normal. If either set of edges is not contiguous, or is empty, we add the vertex to S. Then we identify a subset of points S fragility â S that lead to high fragility. From each point in S, we shoot a ray towards the plane. If it does not intersect the mesh before hitting the plane and if the distance to the plane is below a manually chosen threshold Ï fragility , then we add the point to S fragility . We use 1.5 times the connector diameter as the threshold for all test cases. Tying the threshold to the connector diameter ensures that there is enough room in subsequent cross sections to place a connector as a side effect of the fragility objective. Note that S only needs to be computed once per plane direction instead of once per plane. The ï¬nal fragility objective is: ffragility (T ) = 0 if S fragility = â, â otherwise. (6)

We use two methods for evaluating the structural soundness of a proposed BSP. The ï¬rst attempts to avoid cuts through high-stress areas of the model, given a user-speciï¬ed upright orientation (or gravity direction). Because this method requires a comparatively slow ï¬nite-elements structural analysis, as well as user input about the intended orientation of the object, it is not always desirable. Therefore, we also include a second fragility heuristic that avoids creating thin âï¬nsâ and âbridgesâ in the parts. Structural Analysis: Our structural analysis begins by voxelizing the model on a regular grid, and forming a tetrahedral mesh with six tetrahedra per voxel. We then apply a positional constraint to the lowest 5 percent of exterior tetrahedral vertices (with a minimum of 20 vertices), according to the user-supplied gravity direction. Finally, we apply gravity as an external force, with user-speciï¬ed density and modulus. Using a standard ï¬nite-elements structural analysis, we compute the stress tensor Ï throughout the volume. Then, at run time, we evaluate each cut in T for soundness by integrating the tension Tt and shear Ts computed from Ï and the normal of that plane (compression is ignored, since the resistance of most 3D-printing materials to compression is high): fstructure (T ) =

3.2.4 Aesthetics

Seam Unobtrusiveness: We would like seams to run through parts of the surface where they are least likely to be visible or distracting. For every point on the part surface, we compute a penalty p for running the seam through that point. This penalty is by default based on ambient occlusion (we want seams in self-occluded areas â see Figure 10), but we can also use texture edges if the part is textured, or user input painted onto the model (Figure 11). In all cases, we compute the cost Îµ (C) of the seam S on a cut C as the normalized integral of p along the seam:
Îµ (C) =

1 d0

p dx,
âC

(7)

CâT

â

1 AC

Î±t Tt (x) + Î±s Ts (x) dA,
C

(5)

where d0 is the diagonal length of the input modelâs OBB. The seam objective is deï¬ned as the sum of the the seam costs of each existing C in T plus the estimated seam costs for each unï¬nished part P whose Î(P) > 1: fseam = 1 Î0

where AC is the area of the cut. The weights applied to this objective depends on the materialâs tensile and shear strength.

CâT

â Îµ (C) + â

Ë Î(P) â 1 Îµ (P) ,

(8)

PâT

Ë where Îµ (P) is the estimated seam cost for each future cut on P. We found that the Îµ of the most recent seam on P is a good estimate of Ë Îµ (P) in practice.
P1 P2 P3 P4

Figure 7: A naive partition may place cuts in structurally unsound areas (left). A structural analysis reveals portions of the model under high tension (middle), leading Chopper to select cuts away from the highest-stress areas (right).

Figure 8: Fins (e.g., P1) and bridges (e.g., P2) are locations of potential structural weakness. Our objective distinguishes P1 and P2 from locations such as P3, which is excluded from consideration because it hits P4 before it hits the cutting plane.

Figure 9: Without taking part fragility into account, the yellow part has a thin ï¬n near the tail (left). The fragility objective shifts the cutting plane so that the tail is solidly attached (right). One danger with this seam objective is that it favors planes that cut off only tiny parts. Thus, it is important that its weight be balanced against the utilization objective (Equation 3), which bears the responsibility of preventing such small cuts. Symmetry: To encourage symmetric cuts (Figure 12), we ï¬rst detect the modelâs dominant reï¬ective symmetry by computing the Hausdorff distances between the model and its reï¬ections with respect to uniformly sampled planes (500 directions) passing through the modelâs center of mass. To improve robustness to tessellation, the distance measure is based on a uniform sampling of 10,000 points on the modelâs surface. The plane resulting in the smallest symmetry distance is considered the symmetry plane Ïsymm , as long as that distance is below 0.1 times the bounding box diagonal. The symmetry objective is computed by sampling a set of points P on all the planes of a candidate BSP tree, and computing the rootmean-square (RMS) distance between each point and the closest point under reï¬ection about the symmetry plane. This is normalized by the diagonal of the initial bounding box d0 : fsymmetry =
3.3

Figure 11: Without user guidance, Chopper may cut through salient areas (left). The user may indicate an area that should not be cut (middle), and fseam encourages partitions to avoid it (right).

Figure 12: Taking into account the dominant reï¬ective symmetry of a model discourages off-center cuts (left) and results in a more pleasing partition (right).

1 RMS min p â reï¬ect(q, Ïsymm ) d0 pâP qâP

.

(9) Figure 13: Left: sampled potential connector locations on a crosssection. Right: ï¬nal optimized connector placement. tors at distance d from each other with d < 2rC of each other, we subtract 2Ï (rC â d/2)2 from ci . This ensures that connectors are spaced roughly rC apart. We set Îµ to 10â5 to have a high penalty when a cross-section connected component has no connectors. For some i, ci can be below zero, and for each such ci we add âci /Ci to the objective, to guide the optimization towards a better solution. A state during simulated annealing is simply a subset of all possible connectors. A random mutation performs one of the following actions (with equal probability): (1) picks a connector from among all possible ones and toggles its presence in the state, or (2) removes a random existing connector and adds a different one. We run 15,000 iterations at zero temperature to initialize, and then use a linear cooling schedule and 300,000 iterations for the annealing to improve the placement. A sample result is shown in Figure 13.

Connector Placement

After the beam search, we are left with a number of potential connector locations on each cross-section. Some of them may interfere with each other and not all are necessary: having too many connectors can make the part hard to clean (e.g., of support material used in manufacturing). We use simulated annealing [Kirkpatrick et al. 1983] to place the connectors, minimizing the following objective: wI â Ii, j + â
i, j i

Ci
Îµ + max(0, ci )

,

(10)

where wI = 1010 and Ii, j is 1 if connectors i and j interfere and 0 otherwise. Ci is the area of the cross-section connected component i and ci is the area âcoveredâ by the connectors on that connected component, computed as follows: each connector covers a certain 2 area Ï rC . For large cross-sections, we use rC equal to 20 times the connector radius, but to place more connectors on smaller crossâ sections, we clamp rC to be at most 0.5 Ci . For any two connec-

4

Results

We have evaluated Chopper on a number of models, including mechanical parts, man-made art objects, and organic forms. Figures 1 and 14 show results printed on different 3D printers, ranging from commercial to hobbyist-grade. The chair and kitten were printed on a Fortus 400mc, the helmet and fertility models on an Objet Connex500, and the armadillo on a Bits from Bytes BFB-3000. Figure 10: If seam cost is not penalized, Chopper prefers larger cut cross-sections due to the connector objective (left). With the seam cost penalty, less obtrusive cuts are chosen (right). We found that the commercial printers were able to produce parts that ï¬t together reasonably well, but the Bits from Bytes printer produced signiï¬cant distortion in the printed parts, due to uneven cooling during printing and deformation of parts under their own

Figure 14: 4 Models partitioned by Chopper, then 3D-printed and assembled. weight. This required the use of a smaller effective working volume than the maximum of which the device was capable, further motivating the need for a tool such as Chopper. We also attempted to produce results using an extremely low-cost printer (Makerbot Thing-O-Matic), but found that the printed parts had sufï¬cient deformation to be unusable. We expect that changes to the driver software of such printers could result in more usable prints. Figure 18 shows decompositions and statistics for 16 models. We report wall-clock timings for an Intel Core i7-920 (2.66 GHz). Parallelism is achieved by evaluating batches of cuts with different normals simultaneously (see Algorithm 1); this yields an average speedup of 5.9 across eight hardware threads (four cores). All results in this table were produced with the following weights:
Î±part =1 Î±fragility = 1 Î±util = 0.05 Î±seam = 0.1 Î±connector = 1 Î±symmetry = 0.25

is achieving its goals: matching any âbetterâ cuts produced by humans would likely require changing the objective functions, not the beam-search optimization. Though we have not conducted a formal evaluation of whether Chopperâs partitions are generally preferred to the usersâ, or vice versa, informally we observe that there are few cases in which the usersâ results are obviously better, and those cases require signiï¬cantly more parts (e.g., compare User #4âs 7part armadillo to Chopperâs 5-part result).

6

Conclusion, Limitations, and Future Work

We have explored an automatic and practical method capable of partitioning a wide range of models for 3D printing. Experimental results conï¬rm that the partitions Chopper produces can be printed on a variety of 3D printers and assembled. Our investigation opens up many avenues for future exploration. For example, Chopper currently does handle connectors of different types and sizes for a single object. In our results, the connector size for a few models with thin features was reduced from the default, but Chopper could be extended to automatically consider multiple connector types and sizes and pick the best ones based on the crosssection, surrounding geometry, and structural considerations. A more challenging problem is to relax the restriction that our partitions be BSP trees. While any partition can be represented as a tree, our restriction that cuts must be planar can prevent desirable partitions. The user study indicated that some users feel hampered by this restriction in placing their cuts: for example, they want to cut the kittenâs head off independently from its tail, or to place more natural-looking cuts that follow curved surface features. Any algorithm accommodating non-planar cuts will have to satisfy the same objectives we have identiï¬ed, in particular guaranteeing printability and assemblability. It is possible to test for these properties during the search, though in some cases the check is more complex than for BSP trees (e.g., testing for assemblability requires checking that all normals of the cutting surface lie within in a hemisphere, rather than being guaranteed by construction). A more serious problem is organizing the search over possible cutting surfaces in an efï¬cient way. There are many more possibilities to explore if cutting surfaces may be non-planar, and enumerating plausible candidates is a challenging avenue for future work. Although partitioning models is necessary for objects larger than the printing volume, it can be beneï¬cial for smaller objects as well, even if they could in principle be printed as a single part. For example printing a hollow object as a single part is impossible on most printers because support material cannot be removed. Using partitioning to allow hollow printing, minimizing support material and other objectives are intriguing directions for future research. In our experience with Chopper, it has produced many good partitions, but some have room for improvement. Because the precise desires of a user are difï¬cult to express as objective weights, a reasonable solution would be to put the user in the loop in a more fundamental way. In our prototype, the user can provide guidance by marking rough desirable partition regions on the surface, but Chopper makes the ï¬nal decisions. Instead, the algorithms in

Note that only Î±util , Î±seam , and Î±symmetry need to be carefully adjusted relative to Î±part = 1 for the application: ffragility is either 0 or â and fconnector primarily inï¬uences the result when it is â. There are a few other constants, such as Tn for the fragility objective that can be tuned independently (although we found no need to do this) and others, such as the number of planes that control the tradeoff between the result quality and performance. For our tests, we have manually selected an appropriate scale for each model, though Chopper can of course be applied for any ratio of model size to working volume (Figure 15). Figure 16 shows running time and the resulting objective value, as a function of beam width. The running time is roughly linear in beam width, as conï¬rmed by the slope near 1 in this log/log plot (red line). The objective value typically decreases little in absolute terms (black line), but even this modest numerical improvement results in noticeably better partitions.

5

User Study

To test the plausibility of the partitions produced by Chopper, we have compared its output to the partitions produced by humans. The users were constrained to BSP-tree partitions, as is Chopper, and were given a tool allowing them to add or remove cuts, as well as see information about the current partition. The information provided to the users included the values of all the objective functions used by Chopper, though we observed that in practice users only referred to the number-of-parts estimates. Users were not given any explicit instructions about what kinds of partitions were to be preferred: they were only instructed to partition the model into pieces that ï¬t within the provided printing volume. There were 6 participants in our user study. Each was given 2 models on which to practice, then partitioned a further 4 or 5 models (kitten, armadillo, chair, fertility, ant). Figure 17 shows results on one model, and full results are provided as supplemental material. Chopper was consistently able to produce partitions with equal or lower numbers of parts than did humans, always achieving lower total values of its objective functions. This suggests that the optimization itself (as opposed to the design of objective functions)

0.600 4

1.0995

4

Running Time (min)

Running Time (min)

0.599

Objective Value

Objective Value

1.0990 2

0.598

2

1.0985 1

0.597 1

Figure 15: Reducing the working volume causes this hand model to be partitioned into 10 and 18 parts (cf. original in Figure 18, with 7 parts). Chopper User #1

0.596 1 2 4 8

1.0980 1 2 4 8

Beam Width

Beam Width

Figure 16: Increasing beam width results in decreased objective values, and hence better partitions, at the cost of increased running time. User #2 User #3 User #4 User #5 User #6

5 parts, 139 s

8 parts, 504 s

8 parts, 728 s

6 parts, 346 s

7 parts, 267 s

9 parts, 540 s

7 parts, 252 s

Figure 17: Sample results from a user study comparing Chopper to humans. Full results are provided as supplemental material. Chopper could interactively provide suggestions for cutting planes and feedback (such as min-cover or printing time estimates), but the user would be responsible for the ï¬nal cutting plane. Which solution is ultimately superior is a subject for future investigation. C HEN , X., G OLOVINSKIY, A., AND F UNKHOUSER , T. 2009. A benchmark for 3D mesh segmentation. ACM Trans. Graphics (Proc. SIGGRAPH) 28, 3, 73:1â73:12. D ICKINSON , J., AND K NOPF, G. 1998. Serial packing of arbitrary 3D objects for optimizing layered manufacturing. In Proc. SPIE, vol. 3522, 130â138. E GEBLAD , J., N IELSEN , B. K., AND B RAZIL , M. 2009. Translational packing of arbitrary polytopes. Computational Geometry 42, 4, 269 â 288. F UCHS , H., K EDEM , Z. M., AND NAYLOR , B. F. 1980. On visible surface generation by a priori tree structures. In Computer Graphics (Proc. SIGGRAPH), vol. 14, 124â133. H AO , J., FANG , L., AND W ILLIAMS , R. 2011. An efï¬cient curvature-based partitioning of large-scale stl models. Rapid Prototyping Journal 17, 2, 116â127. H AÅ AN , M., F UCHS , M., M ATUSIK , W., P FISTER , H., AND RUSINKIEWICZ , S. 2010. Physical reproduction of materials with speciï¬ed subsurface scattering. ACM Trans. Graphics (Proc. SIGGRAPH) 29, 3, 61:1â61:10. H ILDEBRAND , K., B ICKEL , B., AND A LEXA , M. 2012. crdbrd: Shape fabrication by sliding planar slices. In Computer Graphics Forum (Proc. Eurographics), vol. 31, 583â592. I KONEN , I., B ILES , W., L EWIS , J., K UMAR , A., AND R AGADE , R. 1998. GARP: Genetic algorithm for part packing in a rapid prototyping machine. In Proc. SPIE, vol. 3517, 54. JANUSZEWSKI , J. 2009. A note on covering a square of side length 2 + Îµ . American Mathematical Monthly 116, 2, 174â178. K IRKPATRICK , S., G ELATT J R , C., V ECCHI , M., AND M C C OY, A. 1983. Optimization by simulated annealing. Science 220, 4598, 671â679. L AU , M., O HGAWARA , A., M ITANI , J., AND I GARASHI , T. 2011. Converting 3D furniture models to fabricatable parts and connectors. ACM Trans. Graphics (Proc. SIGGRAPH) 30, 4, 85:1â85:6.

Acknowledgments
We thank AIM@SHAPE for providing the models and Jonathan Shewchuk for Triangle [Shewchuk 1996] that we used to tessellate the cut surfaces. We thank the members of the Princeton Graphics Group, especially Sema Berkiten, Vladimir Kim, Tianqiang Liu, Jingwan Lu, and Thiago Pereira, as well as Sebastian Koch, Pitchaya Sitthi-Amorn and Justin Lan. This work is partially supported by NSF grant CCF-1012147, IIS-1116296 and ISTC-VC.

References
AGRAWALA , M., P HAN , D., H EISER , J., H AYMAKER , J., K LINGNER , J., H ANRAHAN , P., AND T VERSKY, B. 2003. Designing effective step-by-step assembly instructions. ACM Trans. Graphics (Proc. SIGGRAPH) 22, 3, 828â837. A LEXANDER , P., A LLEN , S., AND D UTTA , D. 1998. Part orientation and build cost determination in layered manufacturing. Computer-aided Design 30, 5, 343â356. ATTENE , M., K ATZ , S., M ORTARA , M., PATANE , G., S PAGN UOLO , M., AND TAL , A. 2006. Mesh segmentation - a comparative study. In Proceedings of the IEEE International Conference on Shape Modeling and Applications 2006, 7â. AUPPERLE , L., C ONN , H., K EIL , J., AND OâROURKE , J. 1988. Covering orthogonal polygons with squares. In Proc. Communication, Control and Computing, 97â106. B ICKEL , B., B ÃCHER , M., OTADUY, M. A., L EE , H. R., P FIS TER , H., G ROSS , M., AND M ATUSIK , W. 2010. Design and fabrication of materials with desired deformation behavior. ACM Trans. Graphics (Proc. SIGGRAPH) 29, 3, 63:1â63:10. C HAZELLE , B. 1981. Convex decompositions of polyhedra. In Proc. ACM Symposium on Theory of Computing, 70â79.

airplane
Parts: 8

Vertices: 5,400 Time: 2.8 min

ant
Parts: 11

Vertices: 6,370 Time: 3.6 min

bearing
Parts: 4

Vertices: 1,663 Time: 48 sec

bird
Parts: 6

Vertices: 3,478 Time: 1.3 min

buste
Parts: 5

Vertices: 12,769 Time: 1.0 min

cup
Parts: 9

Vertices: 15,198 Time: 7.5 min

dolphin
Parts: 6

Vertices: 7,121 Time: 2.5 min

elephant
Parts: 7

Vertices: 24,955 Time: 4.3 min

fandisk
Parts: 6

Vertices: 1,698 Time: 1.9 min

fertility
Parts: 6

Vertices: 49,994 Time: 4.7 min

hand
Parts: 7

Vertices: 2,648 Time: 1.9 min

helmet
Parts: 8

Vertices: 33,262 Time: 6.8 min

human
Parts: 8

Vertices: 4,706 Time: 2.3 min

octopus
Parts: 10

Vertices: 5,944 Time: 2.6 min

rocker arm Vertices: 10,044
Parts: 6 Time: 2.1 min

Figure 18: Results of Chopper on a variety of models (with target working volume shown in gray). Note the connectors on each cross-section. L IEN , J., AND A MATO , N. 2007. Approximate convex decomposition of polyhedra. In Proc. ACM Symposium on Solid and Physical Modeling, 121â131. L OWERRE , B. T. 1976. The harpy speech recognition system. PhD thesis, Carnegie Mellon University. M C C RAE , J., S INGH , K., AND M ITRA , N. J. 2011. Slices: A shape-proxy based on planar sections. ACM Trans. Graphics (Proc. SIGGRAPH Asia) 30, 6, 168:1â168:12. M EDELLIN , H., L IM , T., C ORNEY, J., R ITCHIE , J., AND DAVIES , J. 2007. Automatic subdivision and reï¬nement of large components for rapid prototyping production. Journal of Computing and Information Science in Engineering 7, 3, 249â258. M ORI , Y., AND I GARASHI , T. 2007. Plushie: An interactive design system for plush toys. ACM Trans. Graphics (Proc. SIGGRAPH) 26, 3, 45:1â45:8. S AUL , G., L AU , M., M ITANI , J., AND I GARASHI , T. 2011. SketchChair: An all-in-one chair design system for end users. In Tangible, Embedded, and Embodied Interaction, 73â80. S HAMIR , A. 2008. A survey on mesh segmentation techniques. Computer Graphics Forum 27, 6, 1539â1556. S HEWCHUK , J. R. 1996. Triangle: Engineering a 2D Quality Mesh Generator and Delaunay Triangulator. In Applied Computational Geometry: Towards Geometric Engineering. 203â222. S HEWCHUK , J. 1998. Tetrahedral mesh generation by Delaunay reï¬nement. In Proc. Symposium on Computational Geometry, 86â95. S OIFER , A. 2006. Covering a square of side n + Îµ with unit squares. Journal of Combinatorial Theory A 113, 2, 380â383. S TAVA , O., VANEK , J., B ENES , B., C ARR , N., AND M ECH , R. 2012. Stress relief: Improving structural strength of 3d printable objects. ACM Trans. Graphics (Proc. SIGGRAPH) 31, 4, 1â8. T HRIMURTHULU , K., PANDEY, P. M., AND R EDDY, N. V. 2004. Optimum part deposition orientation in fused deposition modeling. Machine Tools and Manufacture 44, 6, 585 â 594. T OUSSAINT, G. 1983. Solving geometric problems with the rotating calipers. In Proc. IEEE Melecon, vol. 83, A10. U METANI , N., K AUFMAN , D. M., I GARASHI , T., AND G RIN SPUN , E. 2011. Sensitive couture for interactive garment editing and modeling. ACM Trans. Graphics (Proc. SIGGRAPH) 30, 4, 90:1â90:12. W HITING , E., O CHSENDORF, J., AND D URAND , F. 2009. Procedural modeling of structurally-sound masonry buildings. ACM Trans. Graphics (Proc. SIGGRAPH Asia) 28, 5, 112:1â112:9. X IN , S., L AI , C.-F., F U , C.-W., W ONG , T.-T., H E , Y., AND C OHEN -O R , D. 2011. Making burr puzzles from 3D models. ACM Trans. Graphics (Proc. SIGGRAPH) 30, 4, 97:1â97:8.

