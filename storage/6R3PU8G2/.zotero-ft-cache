Computer Aided Geometric Design 35â36 (2015) 163â179

Contents lists available at ScienceDirect

Computer Aided Geometric Design
www.elsevier.com/locate/cagd

Agile structural analysis for fabrication-aware shape editing
Yue Xie a , Weiwei Xu b,â , Yin Yang c , Xiaohu Guo d , Kun Zhou a
a

State Key Lab of CAD&CG, Zhejiang University, China Hangzhou Normal University, China c The University of New Mexico, United States d The University of Texas at Dallas, United States
b

a r t i c l e

i n f o

a b s t r a c t
This paper presents an agile simulation-aided shape editing system for personal fabrication applications. The ï¬nite element structural analysis and geometric design are seamlessly integrated within our system to provide users interactive structure analysis feedback during mesh editing. Observing the fact that most editing operations are actually local, a domain decomposition framework is employed to provide uniï¬ed interface for shape editing, FEM system updating and shape optimization. We parameterize entries of the stiffness matrix as polynomial-like functions of geometry editing parameters thus the underlying FEM system can be rapidly synchronized once edits are made. A local update scheme is devised to re-use the untouched parts of the FEM system thus a lot repetitive calculations are avoided. Our system can also perform shape optimizations to reduce high stresses in model while preserving the appearance of the model as much as possible. Experiments show our system provides users a smooth editing experience and accurate feedback. Â© 2015 Elsevier B.V. All rights reserved.

Article history: Available online 3 April 2015 Keywords: Shape editing FEM Stress analysis 3D printing

1. Introduction The fast developing of rapid prototyping technologies, such as 3D printing, enables convenient manufacturing of real objects from complex 3D digital models. As a prominent example, 3D printing has been extensively adopted in various areas such as architecture construction, industrial design and medical industries. The 3D printing technology converts an input digital model into layers, manufactures each layer and glues them together to shape a real object with various types of technologies, such as selective inhibition sintering (SIS), stereolithography (SLA) and fused deposition modeling (FDM) (Dutta et al., 2000). People can handily fabricate their own designs with emerging low-cost 3D printers and open-source softc wares (Reprap, 2010; VidimË e et al., 2013). To provide novice users feasible controls over the physical properties of the designed objects, many computational design tools have been developed in computer graphics community, i.e. devising objects with desirable structural stability (Stava et al., 2012; Zhou et al., 2013), deformation behaviors (Bickel et al., 2010; Chen et al., 2013) or kinetic constraints (Coros et al., 2013; Zhu et al., 2012). The ï¬nite element method (FEM) is widely adopted in such tools for accurate structural analysis, but it becomes time-consuming when the input digital models are complex. This can downgrade the system usability, especially in cases that users need to iterate the editingâsimulating process. Moreover, most existing methods or commercial CAD/CAE packages only combine design and FEM simulation at the interface layer and users have to do the shape design and

Corresponding author. E-mail addresses: xie.full@gmail.com (Y. Xie), weiwei.xu.g@gmail.com (W. Xu), yangy@unm.edu (Y. Yang), xguo@utdallas.edu (X. Guo), kunzhou@acm.org (K. Zhou). http://dx.doi.org/10.1016/j.cagd.2015.03.019 0167-8396/Â© 2015 Elsevier B.V. All rights reserved.

*

164

Y. Xie et al. / Computer Aided Geometric Design 35â36 (2015) 163â179

FEM simulation in separate stages. A recent contribution aims to update FEM simulation data structures during geometry editing (Umetani et al., 2011b). However, it only focuses on the design problems of moderate-size 2D models using linear elements. Fast design and simulation integrated system for large-scale 3D models using high order elements remains a technical challenge under investigation. In this paper, we present a fabrication-aware shape editing system which can provide structure analysis feedback interactively for large 3D models. The main feature of our system is the seamless integration of FEM simulation and shape editing operations at domain level via the domain decomposition method, a well-known technique in FEM simulation for solving large scale matrix systems (Farhat and Roux, 1991). In our case, such integration enables to assemble the stiffness matrix of the FEM system locally at each domain. Furthermore, the entries of the stiffness matrix can be parameterized as closed-form expressions of the parameters of editing operations at domain-level, such as scaling and rotating. Thus, the FEM system updating speed is largely improved. The editing interface of our system is mainly a skeleton-driven editing interface where domains are connected to form kinematic chains. Scaling operations are also supported at each domain to support stress-relief operations (Stava et al., 2012). We also develop a domain-based optimizer that can optimize the domain geometry parameters to reduce the maximal stress value to a required threshold while preserving model shape. The parameterized entries allow us to compute the derivatives of stiffness matrix with respect to editing parameters easily in the optimization. The optimization algorithm can release the user efforts to manually adjust shapes to improve the structural stability. The distinctive features of our system are:

â¢ Observing that users often perform editing operations locally, such as posing, scaling and thickening parts of a mesh,
we propose to adopt the non-overlapping domain decomposition as a uniï¬ed interface for geometry editing, FEM system updating and shape optimization. Therefore, when only a part of the mesh is modiï¬ed, our system can locally re-assemble the sub-matrices of FEM system belonging to the affected domains while leaving the rest parts untouched. Compared to re-assembling the whole system, a lot unnecessary calculations can be avoided. Our shape optimizer can also take advantage of domain decomposition to decrease the number of optimization variables for fast convergence. â¢ We derive closed-form formulas to parameterize each entry of the stiffness matrix as a polynomial-alike function of the domain scaling factors. With coeï¬cients pre-computed, when a domain is scaled our system could update each entry of its stiffness matrix through 3 multiplications plus 2 additions. Compared to assembling stiffness matrices directly from vertex coordinates, our parametrization method is 2â3Ã faster. â¢ We propose a domain-based shape optimization algorithm that can perform local optimizations to reduce high stresses while preserving the model shape. Observing that the shapes of the mesh parts far away from high stresses are almost not changed during optimizations, our system only chooses the domains close to high stresses as optimizing variables. A constraint list is also dynamically maintained to reduce the cost of constraints enforcement. With the described optimization algorithm, our system can obtain the optimized results within 1â2 minutes. We have tested our system with a variety of 3D models and the results show that our system provides users agile feedbacks. The accuracy of our system is also veriï¬ed through two physical experiments on 3D print-out objects. 2. Related work 3D printing: Since 3D printing technology provides users the opportunities to interact with the designed 3D object in real world, it receives a signiï¬cant amount of research interests in the computer graphics community. In recent years, many techniques are invented to facilitate the printing process, such as adding scaffoldings as support structures (Dumas et al., 2014), decomposing a printable model to separate parts (Hu et al., 2014; Luo et al., 2012), hollowing printable models (Lu et al., 2014) and using skin-frame structures as internal supports (Wang et al., 2013). Research efforts have also been devoted to design algorithms to let the printed 3D objects possess desirable physical properties, such as deformation (Bickel et al., 2010; Skouras et al., 2013), articulation (BÃ¤cher et al., 2012; CalÃ¬ et al., 2012), mechanical motion (BÃ¤cher et al., 2014; Ceylan et al., 2013; Coros et al., 2013; Zhu et al., 2012) and appearance (Chen et al., 2013, 2014; Dong et al., 2010; Lan et al., 2013; PrÃ©vost et al., 2013). 3D printing technology has been adopted in many works as a convenient method of fabrication, for example, in face cloning (Bickel et al., 2012), self-supporting structures (Deuss et al., 2014) and appearance-mimicking surfaces (SchÃ¼ller et al., 2014). Our work is most related to the structural stability analysis of the 3D printable design. Stress relief operations, such as hollowing and thickening, are adopted in Stava et al. (2012) to improve the structural stability of the 3D objects, once areas with high stress are detected. A fast method to analyze worst load distribution that will cause high stress in printed object is developed in Zhou et al. (2013). These two algorithms can be viewed as a post-processing of the 3D design. In contrast, given the material properties which will be used in 3D printing, our goal is to develop an interactive structural analysis algorithm to let the user predict the stress distribution during designing. The structural analysis algorithm can also eï¬ciently handle various external load constraints. Fabrication-aware design: Fabrication-aware design focuses on developing geometric design algorithms that facilitate fabrication. For instance, in architecture geometry, Liu et al. (2006, 2011) developed algorithms to design planar quad mesh for freeform architectural surface to reduce the fabrication cost. To facilitate the 3D shape fabrication, algorithms have been designed to convert the 3D shape into planar slices (Hildebrand et al., 2012; McCrae et al., 2011). Given a 3D furniture model,

Y. Xie et al. / Computer Aided Geometric Design 35â36 (2015) 163â179

165

Fig. 1. The workï¬ow of our system. (a) The input of our system is a tetrahedral mesh. (b) A skeleton is constructed from the input mesh. (c) The mesh is decomposed to domains according to the skeleton, and the decomposed domain is associated with the bones. (d) Users can edit the mesh and see the inï¬uence on stress distribution interactively. (e) Our system also can optimize the shape to reduce stresses. (f) After the stresses are reduced to a safe level, the edited mesh is used to print real objects.

Lau et al. (2011) proposed a method to decompose it into parts and connectors according to fabrication constraints. Recently, Koo et al. (2014) introduced a system for creating works-like prototypes of mechanical objects and Thomaszewski et al. (2014) proposed a system for designing linkage-based characters computationally. The technologies that perform physical simulations during shape design also fall into the area of concurrent engineering, where its philosophy is to take different targets of product design into account in parallel (Liu et al., 2010). In order to allow users to predict the physical properties of the designed object, fast simulation techniques are integrated into design system so that the inï¬uences of changing geometric parameters on the physical properties can be eï¬ciently computed. Its typical applications include plush toy design (Mori and Igarashi, 2007) and sensitivity analysis based cloth design (Umetani et al., 2011a). Sensitivity analysis technique is also adopted in furniture design to fast compute the structural stability (Umetani et al., 2012). Our work can be viewed as a fabrication-aware design algorithm, as we provide users interactive tools to edit the shape of the printable models, and integrate FEM simulation into our system to provide user structure analysis feedback. Domain decomposition: Domain Decomposition (DD) is a numerical technique originally designed for solving partial differential equations (PDEs) (Toselli and Widlund, 2004) inspired by the idea of divide and conquer. Farhat et al. (2001, 1991) propose large-scale iterative DD solvers, which use Lagrange multipliers to enforce continuity constraints on the interface between domains and can be executed on multiple cores in parallel. In the computer graphics community, similar ideas have also been adopted in FEM based animation techniques. Nevertheless, in order to achieve a real-time simulation performance, simpliï¬cations have been applied, for example the assumption of interface rigidity (BarbiË and Zhao, 2011), penalty c forces based soft coupling (Kim and James, 2011), or with reduced boundary freedoms (Yang et al., 2013). Instead of using DD as a computing technique, we use DD as a strategy to take advantage of locality. Our system adopts DD as a uniï¬ed interface for shape editing, FEM system updating and shape optimization, while still solves the FEM system using direct factorization. 3. System overview In this section, we brieï¬y introduce each stage of our system. The pipeline of our system is illustrated in Fig. 1. Skeleton construction: The input of our system is a tetrahedral mesh which consists of a set of vertices and a set of tetrahedrons. A set of bones B = {b1 , b2 , . . . , bn } is constructed from the mesh to form a skeleton which is used as the editing interface. An example of the constructed skeleton can be seen in Fig. 1(b). Domain decomposition: According to the skeleton, the tetrahedral mesh is decomposed into a set of domains D = { D 1 , D 2 , . . . , D n }. Each domain comprises its own sets of vertices and tetrahedrons. Each tetrahedron of the mesh belongs to one and only one domain, while the vertices on interfaces between domains are duplicated. Each domain has its own local coordinate system and its vertices are transformed into the local coordinate system. Based on the associations between domains and bones, we classify the domains to two types: type R and type F . A domain of type R is associated with only one bone. Its local coordinate system is built on the bone and its mesh is completely translated, rotated and scaled with the bone. In its local coordinate system, the vertex coordinates could be viewed as functions of the three scaling factors, thus the entries of the stiffness matrix assembled from the vertex coordinates are functions of the scaling factors too. We derive closed-form formulas to parameterize these entries, using the scaling factors as the parameters. A domain of the other type F is associated with multiple bones simultaneously. Its local coordinate system can be built on an arbitrary associated bone. Its vertex coordinates are transformed with each

166

Y. Xie et al. / Computer Aided Geometric Design 35â36 (2015) 163â179

associated bone then blended. We do not parameterize the stiffness matrices of domains of type F . An example of domain decomposition can be seen in Fig. 1(c). As can be seen from the example, most parts of the mesh are in domains of type R. Shape editing: After all domains associated to the bones, users can begin to manipulate the mesh by adjusting the skeleton. Our system integrates the Forward Kinematic technique (FK) and the Inverse Kinematic technique (IK) to let users translate and rotate the bones, consequently translate, rotate and blend the associated domains. Our system also let users scale the bones associated with domains of type R, which consequently scale the associated type R domains and blend the adjacent type F domains. Please watch the accompanied video to see the effects of editing. FEM simulation integration: When users are editing the mesh, our system runs FEM simulations in background to provide structure analysis feedback interactively. Same to Stava et al. (2012), our system solves the standard static equilibrium equation for the vertex displacements:

Ku = f

(1)

where K is the stiffness matrix assembled from the mesh using quadric tetrahedral elements, f is the external loads, and the solution u is the vertex displacements reacting to the external loads. As soon as the mesh is edited by users, our system updates the stiffness matrix K to synchronize the FEM system with the edited mesh. Instead of re-assembling the whole K, a domain-based local update scheme is used. Our system maintains local stiffness matrices for each domain, and K is assembled from these local stiffness matrices. When the mesh is edited, our system detects the affected domains and only re-assembles the local stiffness matrices of these domains. Then the entries in K contributed by these domains are updated with the re-assembled local stiffness matrices. The local stiffness matrices of domains of type R are parameterized and thus can be re-assembled very eï¬ciently. After K is updated and (1) is solved, our system calculates the Von-Mises stress of every vertex using (21) and visualizes the Von-Mises stress distribution on the surface of the mesh. The magnitudes of the Von-Mises stresses are represented by different colors, as in Fig. 1(d). From such feedback, users are aware of the inï¬uences of their edits on the stress distribution, thus can avoid editing operations causing high stresses in the model. Our system is also able to provide error estimations of the computed Von-Mises stress values to users. We adopt the method in Zienkiewicz and Zhu (1987), where an improved stress distribution is ï¬rst computed on vertices and then accuracy errors are calculated in percentage with the difference between the original and improved stress values. Scaling optimization: In addition to providing feedback interactively during editing, our system can also perform a domainbased shape optimization to automatically reduce the maximal stress in the model. Users can set a Von-Mises stress threshold based on the material to be used in 3D printing. Our system detects a set of domains having Von-Mises stresses larger than the threshold and optimizes their scaling factors. The result is a mesh most close to the mesh before optimization and satisï¬es the stress constraints, as in Fig. 1(e). Fabrication: After users ï¬nish their editing and ensure there are no structure stability problems may be caused from high stresses, the edited mesh can be used to print real objects. An example is shown in Fig. 1(f). In the following sections, we describe each technique used in our system in detail. Section 4 introduces the methods for skeleton construction and domain decomposition. Section 5 derives the formulas for stiffness matrix parametrization. Section 6 describes the details of the FEM system updating. Section 7 discusses the scaling optimization. Section 8 describes the method we used for error estimation. Finally we demonstrate our system with several results in Section 9, conclude and discuss the limitations and possible future works in Section 10. 4. Pre-processing In pre-processing, we construct a skeleton from the input mesh for the subsequent editing. The input mesh is decomposed to domains based on the skeleton structure, and the domains are associated with the bones. Â´ We adopt the automatic rigging system, Pinocchio, in Baran and Popovic (2007) for skeleton construction. The Pinocchio system pre-deï¬nes a set of skeletons for common animal and human models, and automatically embeds these skeletons into the input meshes. Our system allows users to edit the skeleton outputted from the Pinocchio system, like inserting new joints and adjusting joint positions. An example of the constructed skeleton can be seen in Fig. 1(b). The Pinocchio system also computes the skinning weights for the surface vertices of the mesh, which can be used for domain decomposition. We extend the skinning weights of the surface vertices to the interior vertices by solving the Laplace equation:

w=0

(2)

where the components of w are the weights of the internal vertices and the Laplace operator is calculated using Mean Value Coordinates (Tao et al., 2005). The solved weights are consistent with the weights of the surface vertices and vary smoothly inside the tetrahedral mesh.

Y. Xie et al. / Computer Aided Geometric Design 35â36 (2015) 163â179

167

Fig. 2. Domain decomposition. D 1 (red), D 2 (blue) and D 3 (green) are type R domains and are associated with bones b1 , b2 and b3 respectively. D 4 (white) is a type F domain adjacent to D 1 , D 2 and D 3 , and is associated with b1 , b2 and b3 simultaneously. The orange points represent vertices on the interface between domains and are duplicated into the domains on both sides. (For interpretation of the references to color in this ï¬gure legend, the reader is referred to the web version of this article.)

For each bone b i , we perform a region growing to detect tetrahedrons completely transformed with b i . The region grows through face adjacency, which means a tetrahedron could be merged only if it shares a neighboring face with any already merged tetrahedron. We set a default weight threshold (0.95) such that a tetrahedron is merged only if the average weight of its four vertices is larger than the threshold. The tetrahedrons detected in this way form a domain of type R and is associated with b i . We allow users to modify the domain by tuning the weight threshold and adding/removing individual tetrahedrons, provided the face adjacency property is preserved. After all domains of type R are detected, the left tetrahedrons are grouped to domains of type F , according to face adjacency. Such domains are simultaneously associated with multiple bones, an example could be seen in Fig. 2. The mesh of a type F domain is transformed with each associated bone then blended. To compute the blend weights for each type F domain, any mesh blend method can be used, providing the mesh continuities between domains of type R and domains of type F are enforced. For the sake of simplicity, we use linear blend and calculate the blend weights using the Laplace equation (2) with suitable boundary conditions. For example, as in Fig. 2, to calculate the blend weights of vertices of D 4 for b1 , we assign the weights on the interface between D 4 and D 1 all 1 and the weights on the interfaces between D 4 and D 2 , D 4 and D 3 all 0, then solve the Laplace equation on all internal vertices of D 4 . With the blend weights solved in this way, the continuities between domains of R and domains of F are enforced and the meshes in domains of F are smoothly blended.

5. Stiffness matrix parametrization

In this section, we show that each entry of the stiffness matrix of a quadratic tetrahedral mesh can be expressed as a polynomial. All these polynomials share a few same variables, which are arithmetic expressions formed by the scaling factors s x , s y and s z along X Y Z axes. The coeï¬cients in these polynomials only depend on the vertex coordinates of the unedited mesh and the material parameters, thus can be pre-computed. When the mesh is scaled along X Y Z axes, we can update the stiffness matrix by ï¬rst computing these variables from s x , s y and s z then re-evaluating the polynomial for each entry. We use the quadratic tetrahedrons of our input mesh as the ï¬nite elements, and each element has 10 nodes which are the 10 vertices forming the tetrahedron, as shown in Fig. 3. Following the convention in FEM textbook (Zienkiewicz et al., 2008), the stiffness matrix Ke of an element e can be assembled as:

Ë
Ke = B T DBdxd ydz (3)

D is the 6 Ã 6 stressâstrain relation matrix formed from the material properties. In our application, we use isotropic material model. B is the 6 Ã 30 strainâdisplacement relation matrix:

B = B1 . . . B10

(4)

168

Y. Xie et al. / Computer Aided Geometric Design 35â36 (2015) 163â179

Fig. 3. Quadratic tetrahedral element.

where

â¡ â Ni â¢ â¢ â¢ â¢ Bi = â¢ â N i â¢ â¢ ây â¢ â£
â Ni âz âx â Ni ây â Ni âx â Ni âz â Ni âz â Ni ây â Ni âx

â¤ â¥ â¥ â¥ â¥ â¥ â¥ â¥ â¥ â¦

(5)

N i denotes the shape function of node i. The entries of the 3 Ã 3 sub-matrix BiT DB j can be calculated with simple matrix multiplications. For example, the expression of the top-left entry is:

(BiT DB j )00 =

E

(1 + v )(1 â 2v ) Ë

((1 â v )

â Ni â N j (1 â 2v ) â N i â N j (1 â 2v ) â N i â N j + + ) âx âx 2 ây ây 2 âz âz

(6)

where E and v are Youngâs modulus and Poissonâs ratio of the material, both are constants. Substitute (6) into (3); one can observe that the basic terms in the expressions of entries in Ke share the same form:

c(i , j , Î¸1 , Î¸2 ) =

â Ni â N j dxd ydz, âÎ¸1 âÎ¸2

Î¸1 , Î¸2 = x, y , z

(7)

where Î¸1 and Î¸2 are dummy variables which can be x, y or z. As showed in Zienkiewicz et al. (2008), within a quadratic tetrahedral element, the shape functions can be represented as:

N i = (2L i â 1) L i , N 5 = 4L 1 L 2 , etc.

i = 1, 2, 3, 4 (8)

where L i is the 3D barycentric coordinate with respect to the i-th node of the element. When i > 4, the node is on an edge and its shape function N i is the product of the shape functions of the two end nodes of the edge. The expression of c can be derived by substituting (8) into (7). For different combinations of the parameters, c has different forms, but the derivations are similar. Here we derive c(1, 1, x, x) as an example, the complete formulas can be found in Appendix A at the end of the paper. Suppose we are given an edited tetrahedron t = {vi , i = 1 . . . 10}, where vi = (xi , y i , zi ) T is the position of the i-th node and is computed by:

xi = s x xi , y i = s y y i , z i = s z z i

(9)

where (xi , y i , zi ) T are the unedited position coordinates and are treated as constants. The barycentric coordinate of a point P (as in Fig. 3) with respect to the 1-th node is computed as:

L1 =

Vol P 234 Vol 1234

=

a1 + b 1 x + c 1 y + d1 z 6V

(10)

Here Vol represents the volume computation for the tetrahedron formed by the following 4 points. V is the volume of the edited tetrahedron and can be computed by V = s x s y s z V , where V is the volume of the unedited tetrahedron. (x, y , z) T are the coordinates of the point P . a1 will not appear in the ï¬nal expression, while b1 , c 1 and d1 are calculated as (Zienkiewicz et al., 2008):

1 b1 = â 1 1

y2 y3 y4

1 z2 z3 = â 1 z4 1

y2 y3 y4

z2 z3 s y s z = b 1 s y s z , z4

Y. Xie et al. / Computer Aided Geometric Design 35â36 (2015) 163â179

169

1 c1 = + 1 1 1 d1 = â 1 1

x2 x3 x4 x2 x3 x4

1 z2 z3 = + 1 z4 1 1 y2 y3 = â 1 y4 1

x2 x3 x4 x2 x3 x4

z2 z3 s x s z = c 1 s x s z , z4 y2 y 3 s x s y = d1 s x s y y4 (11)

N Using (10) and (11), the partial derivative ââ x1 in the integrand of c (1, 1, x, x) is calculated as:

b s y sz â N1 = (4L 1 â 1) 1 âx 6V sx s y s z
Substitute (12) into (7), and use the integration equation for 3D barycentric coordinate functions:

(12)

Ë

L 1 L 2 Ll3 L m dxd ydz = 4
we ï¬nally have:

p q

p !q!l!m!

( p + q + l + m + 3)!
2

6V

(13)

Ë
c(1, 1, x, x) =

2 2 â N1 â N1 1 b1 s y s z dxd ydz = âx âx 60 V sx s y s z

(14)

Thus c(1, 1, x, x) could be regarded as a one-term polynomial with coeï¬cient

Î± and variable m(x,x) :
(15)

c(1, 1, x, x) = Î± m(x,x) ,

Î±=

1 b1 60 V

2

, m(x,x) =

s2 s2 y z sx s y s z

where Î± only depends on the unedited mesh and can be pre-computed. All types of c can be expressed as the product of a coeï¬cient Î± and a variable m. According to the different combinations of the dummy variable Î¸1 and Î¸2 , there are totally 6 types of m and all of them are similar to m(x,x) , only formed by the three scaling factors. This indicates that all entries of Ke can be expressed as 1-order polynomials of 6 variables. Then if all the tetrahedrons in a domain are scaled with the same scaling factors, as in domains of type R, the entries in the stiffness matrix of the whole domain are also 1-order polynomials of the 6 variables, and can be computed through polynomial summations. Checking the expression of each entry of BiT DB j (such as (6)), we can see that only three types of m are used for an entry on the diagonal of BiT DB j while only two are used for an entry off the diagonal. And the pattern of variable types is same for all BiT DB j . Thus for every entry of the stiffness matrix, only two or three coeï¬cients are needed to be stored. With these coeï¬cients pre-computed from the unedited mesh, only 2â3 multiplications plus 1â2 additions are needed to evaluate an entry. The same coeï¬cients can also be used to evaluate the partial derivatives of each entry with respect to the scaling factors, as the formulas for the partial derivatives can be derived by simply differentiating each m with respect to s x , s y and s z . Thus our parametrization also can be used to compute the partial derivatives of the stiffness matrix, which are required in the shape optimization algorithm described in Section 7. For domains of type F , the derivations in this section also provide a closed-form method to assemble the stiffness matrix directly from vertex coordinates, with no needs for numerical quadratures. 6. FEM system updating As stated in Section 3, our system solves the standard equilibrium equation (1) for the vertex displacements. Whenever an editing operation is committed, our system needs to update the stiffness matrix K in (1) to synchronize with the edited mesh. In this section, we describe the local update scheme used in our system and the details of updating K. 6.1. Local update scheme We observe that most editing operations only affect a few parts of the mesh, thus we can update K by only re-evaluating a small fraction of entries in K. We demonstrate this idea with a simple 1-D example. Consider the simple 1-D structure formed by two springs in Fig. 4. Assume the stiffness matrices of the two elements e 1 and e 2 are:

Ke1 =

1 k11

e

1 k12

e

e1 k21

e1 k22

,

Ke2 =

2 k11

e

2 k12 2 k22

e e

e2 k21

(16)

170

Y. Xie et al. / Computer Aided Geometric Design 35â36 (2015) 163â179

Fig. 4. A 1-D two elements example.

Then the global stiffness matrix K g for the whole structure is assembled by adding the entries of Ke1 and Ke2 to the corresponding entries in K g :

â â

1 k11

e e

1 k12 1 2 k22 + k11 2 k21

e

â
e
2 k12 â  2 k22

1 K g = â k21

e

e e

â

(17)

e

When only the element e 2 is changed, Ke2 is changed while Ke1 remains the same. Consequently, K g is changed to:

â â

1 k11

e e

1 k12 1 Ë 2 k22 + k11

e

â
e

1 Ë K g = â k21

e

Ë 2 k12 â 
e

â

(18)

Ëe k 2

21

Ëe k 2

22

where the hat on a symbol means its value is changed. Ë Compare K g with K g ; we can see that only the four entries in the bottom-right corner which are contributed by e 2 are e1 Ë e2 Ë changed. Most of these changed entries can be updated by just re-assembling Ke2 . The only exception is the entry k22 + k11 e1 e1 e1 that is related to the vertex on the interface between e 1 and e 2 , which also needs the entry k22 in K . K is not changed e1 so that k22 can be re-used and only an extra addition is needed. This means when only a few elements of a structure are changed, the global stiffness matrix of the structure can be updated by only re-assembling the stiffness matrices of the modiï¬ed elements plus performing extra additions for the entries related to the vertices on the interfaces between these elements. The same idea can be extended to our domain decomposition case. The global stiffness matrix K can be updated locally in units of domains. We divide the entries in K to two types: entries contributed by only one domain and entries contributed by multiple domains simultaneously. When a domain is modiï¬ed, the affected entries of the ï¬rst type can be updated by just re-assembling the local stiffness matrix of the modiï¬ed domain, while the affected entries of the second type require extra additions. The entries of the second type are only related to vertices on the interfaces between domains, thus only count a small fraction in the whole matrix. We design special data structures to facilitate the local updating scheme. For each domain, we store the positions of the entries in K that are contributed by this domain. For each non-zero entry k in K, we use a list L to record the domains contributing to it. Further, for each domain recorded in L, the position of the entry in its local stiffness matrix Ki that is added to k is also stored. For most entries, L only contains one domain. When a set of domains are edited, our system ï¬rst updates the Ki of each edited domain, then locates the affected entries in K and updates these entries by summing the contributions from the domains recorded in L. 6.2. System updating Instead of assembling K directly from the mesh in a straightforward manner, our system organizes the assembling of K in units of domains. Each domain maintains its local stiffness matrices and the global stiffness matrix is assembled and updated from these local stiffness matrices using the local update scheme described in Section 6.1. For each domain D i , our system stores three matrices: Ki , Ri and Ki . Ki is the local stiffness matrix and is assembled from the mesh decomposed into D i in the local coordinate system. For all domains of type R, Ki is parameterized with the three scaling factors along the X Y Z axes of the local coordinate system; for all domains of type F , Ki is directly assembled from the vertex coordinates. Ri is a rotation matrix transforming a 3-D vector from the local coordinate system of D i to the global coordinate system. Ki is the local stiffness matrix of D i in the global coordinate system, and is calculated by:

Ki = Ri Ki RiT

(19)

Ki is the matrix used to update K in the local update scheme. With the editing interface of our system, a domain can be modiï¬ed in four manners: translation, rotation, scaling and blend. Only domains of type R will be scaled while only domains of type F will be blended. Translating a domain has no effects on its local stiffness matrices. Rotating a domain D i changes Ri . Scaling a domain of type R causes our system to re-assemble Ki using parametrization. Blending a domain of type F causes our system to re-assemble Ki directly from the new-blended vertex coordinates. If either Ri or Ki is changed, Ki needs to be re-calculated. Before users begin editing, our system performs a pre-computation to initialize the simulation system. For each domain D i , our system allocates its Ki , Ri and Ki . For each domain of type R, our system pre-computes the coeï¬cients used in the parametrization of Ki . And the global stiffness matrix K is allocated and symbolically factorized. The data structure

Y. Xie et al. / Computer Aided Geometric Design 35â36 (2015) 163â179

171

Fig. 5. Example of Dopt . Only the four domains having Von-Mises stresses above the threshold (60 MPa) are added into Dopt .

used for local update scheme is also built. As the editing operations in our system donât change the topology of the mesh, the sparse matrix structures of the stiffness matrices are re-used in subsequent updates. When users make an edit, our system ï¬rst determines the affected domains. Then for each affected domain, our system maintains its local stiffness matrices in the manner described above. Finally K is updated using the local update scheme. 7. Scaling optimization In addition to providing the editing interface, our system can also optimize the scaling factors of domains of type R to reduce the Von-Mises (VM) stresses in the model. The objective function of the optimization is formulated as the difference between the vertex coordinates before optimization and the vertex coordinates after optimization, and is minimized to preserve the shape of the mesh. Inequalities constraints are used to enforce that the VM stresses of the vertices are under a user speciï¬c threshold after optimization. High stresses usually occur at the thin parts of the mesh, and can be reduced by adjusting the thicknesses of the mesh parts near the high stresses. With our system, thickening and thinning parts of the mesh can be easily achieved by adjusting the scaling factors of the type R domains, thus their scaling factors become a nature choice for optimization variables. We also observe that adjusting the thickness of a part of the mesh far away from the high stresses has very little effects on reducing the high stresses, so we only choose the domains near the high stresses. We denote the set of domains used in the optimization by Dopt , a domain D i of type R is added into Dopt if: (1) D i itself has stresses larger than the user speciï¬c threshold; or (2) D i is adjacent to another type F domain D j while D j has stresses larger than the threshold. Fig. 5 shows an example of Dopt . Further, for each domain in Dopt , we only use the two scaling factors along the two axes perpendicular to the associated bone. We also found that directly constraining the VM stress on every vertex is ineï¬cient, even slows down the performance of the system to an unacceptable degree. Thus instead of constraining every vertices, we only monitor the vertices having the maximal VM stresses. Our system dynamically maintains a set of constrained vertices Vconstrain during the optimization and only enforces constraints on the vertices in Vconstrain . At the beginning of the optimization, Vconstrain only contains one vertex that has the maximal VM stress in the whole mesh. In each iteration, whenever a vertex not in Vconstrain becomes the vertex having the maximal VM stress, it is added into Vconstrain . In the worst case, all vertices of the mesh could be added into Vconstrain , which is equivalent to constraining all vertices. From our test results, there are always only several vertices in Vconstrain at the end of the optimization. With the set of chosen domains Dopt and the set of constrained vertices Vconstrain , we formulate the optimization as:

min v(s) â v(s0 ) s.t.

2

v threshold â v â Vconstrain , Ïvm < Ïvm

(20)

where s is a vector containing the scaling factors of the domains in Dopt , s0 is a vector containing the same scaling factors before the optimization, v(s) and v(s0 ) are the vector coordinates of the mesh scaled with s and s0 . For a vertex v in v threshold Vconstrain , Ïvm is its VM stress. Ïvm is the user speciï¬c VM stress threshold. v For a vertex v, Ïvm is calculated as (Logan, 2012):
v 2 2 2 Ïvm = â ((Ïx â Ï y )2 + (Ï y â Ïz )2 + (Ïz â Ïx )2 + 6(Ïxy + Ï yz + Ïzx )) 2

1

1

2

(21)

The terms

Ï and Ï are the components of vertex stress Ï v . Within an element e, Ï v is calculated as:
(22)

Ï v = ( Ïx Ï y Ïz Ïxy Ï yz Ïzx )T = DBue

172

Y. Xie et al. / Computer Aided Geometric Design 35â36 (2015) 163â179

where D and B are the stressâstrain relation matrix and the strainâdisplacement relation matrix same as in (3). ue is the v vector containing the displacements of the vertices of e. Using quadratic tetrahedral elements, Ï is discontinuous on the interface between two elements, thus for every vertex we calculate the average value of its stresses within its incident elements. As the objective function is quadratic and the constraints are non-linear, we adopt the Sequential Quadratic Programming v (SQP) method. We linearize Ïvm as:
v v Ïvm (s + s) â Ïvm (s) + v â Ïvm (s) s âs

(23)

Then during the k-iteration, we solve the Quadratic Programming (QP) problem:

min v(sk + s.t.
for

s) â v(s0 )

2 v â Ïvm threshold (sk ) s < Ïvm âs

v â v â Vconstrain , Ïvm (sk ) +

(24)

s and update the scaling factors as:

sk+1 = sk +

s

(25)

The partial derivative in (23) can be calculated by using the chain rule:
v âÏ v âÏ v â Ïvm (sk ) = vm (sk ) (sk ) v âs âs âÏ

(26)

The ï¬rst term in (26) is straightforward and we describe how to compute the second term. From (22), the partial derivative v of Ï with respect to a component s of s is computed as:

â ue âÏ v âB (sk ) = D (sk )ue (sk ) + DB(sk ) (sk ) âs âs âs

(27)

D is constant. B changes with the vertex coordinates of the element e, thus is only related to these s affecting e. Its partial derivative is 0 for other s and we compute the non-zero ones by ï¬nite differences. e ue is computed as a part of u which contains the displacements of the whole mesh. Similarly ââu is computed as a s

part of â u . u is obtained by solving (1), and we adopt the sensitivity analysis technique (Arnout et al., 2012) to calculate âs its partial derivatives: differentiate both sides of the equilibrium equation (1) with respect to s, then after some simple re-arrangements we get:

âf âK âu (sk ) = K(sk )â1 ( (sk ) â (sk )u(sk )) âs âs âs

(28)

Different entries in f and K are contributed by different domains, thus for each s only the entries contributed by the domains changing with s have non-zero partial derivatives with respect to s. Such entries in K can be located using the data structure for the local update scheme, as described in Section 6.1. For entries contributed by domains of type R, their partial derivatives can be computed using the parametrization, as described in Section 5. For entries contributed by domains
âf of type F , we compute their partial derivatives by ï¬nite differences. â s is also computed by ï¬nite differences. The inverse matrix K(sk )â1 need not to be computed explicitly, as computing Aâ1 y equals solving Ax = y for x. K(sk ) could be updated using the local update scheme, and only needs to be factorized once for each iteration. The iterating of the optimization is determined as converged when two conditions are satisï¬ed simultaneously: (1) no more new vertex is added into Vconstrain , and (2) the relative change of the objective function between two successive iterations is below a threshold . In our tests, we set as 1eâ4. The whole algorithm is described in Algorithm 1.

8. Error estimation For the purpose of interactive performance and the simple formulations of the derivative of stress to editing parameters in optimization, our system computes the stress on each vertex by averaging operation. To let users predict the accuracy of the analysis, our system is also able to estimate the error using the method in Zienkiewicz and Zhu (1987). First, an improved vertex stresses Ï are computed by solving the equation:

Ë
N T Nd

Ë

Ï =

N T DBd u

(29)

Y. Xie et al. / Computer Aided Geometric Design 35â36 (2015) 163â179

173

Data: vertices set V , tetrahedrons set T , scaling factors s0 Result: optimized s 1 initialize Dopt , Vconstrain ; 2 s = s0 ; 3 while not converge do
4 5 6 7 8 9 10 11 end

calculate

v â Ïvm (sk ) for every v in âs

Vconstrain using (23);

solve the QP problem (24) for s; s = s + s; update vertex coordinates V with s; calculate Von-Mises stresses of all vertices; update Vconstrain ; update the objective function (20);

Algorithm 1: The SQP algorithm. where represents the elements of the mesh, N is the matrix of shape functions, D and B are the stressâstrain relation matrix and strainâdisplacement relation matrix, and u is the vertex displacements solved from (1). The percentage error Î· in energy norm is then computed as:

Î·=
where

e u

(30)

â¡
e =â£
and

Ë

â¤1

2

T eÏ D â 1 eÏ d â¦ ,

eÏ = NÏ â DBu

(31)

â¡
u =â£

Ë

â¤1
u B DBud â¦
T T

2

(32)

Finally Î· is multiplied by an empirical correction multiplying factor. Consulting the factors used in Zienkiewicz and Zhu (1987), we use 1.5 for our quadratic tetrahedral element. 9. Results We implement our system on a desktop PC equipping an Intel i7-4770 3.4 GHz CPU and 16 GB RAM. The standard equilibrium equation (1) is solved with the Direct Sparse Solver (DSS) module of the MKL library, through matrix factorization and back-substitution. The Quadratic Programming problem (24) is solved using the ALGLIB library. Except the parallelism in MKL, all computations are executed in a single thread. In all tests we use the typical parameters of Polylactic Acid (PLA) material, which is widely used in 3D printing. Youngâs modulus is set as 2.3e9 N/m2 , Poissonâs ratio is set as 0.35, and density is set as 1300 kg/m3 . In addition to the user-speciï¬ed forces, the gravity is also taken into account and the gravity acceleration is set as 9.8 m/s2 . The yielding strength of PLA is about 60 MPa and we use 55 MPa as the Von-Mises stress threshold in optimization for safety. The real objects are printed by an FDM 3D printer using the PLA material. Fig. 6 shows our experiment on an opener model. We measured the loads that an opener undertakes when opening a beer bottle, and simulated the same loads in our system (a, b). From the analysis results provided by our system, we were aware that the printed object might break when opening a bottle, because the high stresses occur at these red regions exceeded the yielding strength of the material (d). With the editing interface of our system, we thickened parts of the mesh, balancing the structure stabilities against appearances. After editing, our system predicted the stresses had been reduced to a safe level (f). We printed two real objects from the unedited mesh and the edited mesh respectively, and tested them by opening real bottles. The opener printed form the unedited mesh broke in the test, and the position of the crack matches the high-stress region in the analysis result (c). The opener printed from the edited mesh survived the test (e). Fig. 7 shows another experiment on a bird model. The leg parts of the model are thin and are easy to break. From the analysis result provided by our system, we were aware that very high stresses would occur if a 5 N force were exerted on a leg of the model. This time we let our system optimize the mesh to enable the printed model to undertake the force. The experiments on the printed objects match the prediction of our system, as the object printed from the unedited mesh broke during the experiment, while the object printed from the edited mesh survived the experiment. The dinosaur model in Fig. 1 is another example. We adjusted its pose using the IK tool, and scaled its head. From the structure analysis feedback provided by our system, we knew high stresses might occur on the left leg of the model (d).

174

Y. Xie et al. / Computer Aided Geometric Design 35â36 (2015) 163â179

Fig. 6. Opener experiment. (a, b) We measured the loads with an electric spring scale. The magnitude of the forces exerted on different parts of the opener are computed by torque equilibrium. (c, d) Before editing, our system predicted that the maximal Von-Mises stress in the model exceeded the yielding strength of the material, and the printed object broke in the experiment. (e, f) After editing, our system predicted that the high stresses had been reduced, and the printed object survived the experiment. (For interpretation of the references to color in this ï¬gure, the reader is referred to the web version of this article.)

Fig. 7. Bird experiment. Left: the object printed from the unedited model broke when a 5 N force was exerted on the leg, as predicted by our system. Right: after optimization, the printed object survived the physical experiment. The larger ones of the two optimized scaling factors of each leg domain are marked on the ï¬gure.

Then we let our system optimize the mesh and the left leg be thickened to reduce the stresses. For aesthetic reason, we manually scale the right leg to match the left leg. The edited mesh is used to print a real object as in (f). Other two similar examples are showed in Fig. 8. Table 1 lists the size of each test 3D model. Table 2 reports the performance of our systemâs underlying solver, which is updated with the method described in Section 6.2, taking advantages of stiffness matrix parametrization (Section 5) and local update scheme (Section 6.1). In addition to model size, the performance also depends on the number of tetrahedrons and vertices decomposed into domains of type R. From the table we can see that assembling the stiffness matrix using parametrization is usually 2â3 times faster than assembling the matrix directly from vertex coordinates using the closed-form formulas, and local updating can be 6â20 times faster. For all test models, our system can provide the structure analysis feedback within few seconds after users make an edit.

Y. Xie et al. / Computer Aided Geometric Design 35â36 (2015) 163â179

175

Fig. 8. More scenes. Left: domain decompositions and load conï¬gurations. Middle: shape editing results, high Von-Mises stresses are presented by red color. Right: meshes after optimization, the maximal scaling are marked on the ï¬gure. (For interpretation of the references to color in this ï¬gure legend, the reader is referred to the web version of this article.)

Table 1 Scene sizes. Total, R and F means number in the whole mesh, number in all domains of R and number in all domains of type F respectively. Scene Domain # Total Opener Bird Horse Dinosaur Earphone 5 23 26 27 34 Tetrahedron # Vertex #

R
3 12 15 16 15

F
2 11 11 11 19

Total 38,729 58,911 15,869 31,409 42,944

R
33,293 46,996 7813 21,158 37,180

F
5436 11,915 8056 10,251 5764

Total 73,640 115,232 29,522 61,407 81,977

R
64,092 94,019 15,840 43,163 71,811

F
10,652 25,919 15,802 21,549 13,248

Table 2 The performance of our systemâs underlying solver. From left to right, Sparse structure: time of allocating the local stiffness matrices of every domain and the global stiffness matrix, building the data structure for local update scheme, and symbolically factorizing the global stiffness matrix. Calc Poly Coef: time of pre-computing the polynomial coeï¬cients of the stiffness matrix parametrization. Direct assemble: time of evaluating all entries in the global stiffness matrix directly from vertex coordinates. DD assemble: the ï¬rst number is the time of evaluating all entries in the global stiffness matrix, using parametrization for domains of type R; the second number is the time of updating the global stiffness matrix with the local update scheme, using parametrization for domains of type R. As system updating varies according to the editing operations, the second number is an average value of a sequence of edits similar to those editing operations recorded in the video. Solve: time of solving the system, including numerical factorization and back substitution. Scene Opener Bird Horse Dinosaur Earphone Sparse structure (s) 3.48 5.46 1.47 3.15 3.82 Calc Poly Coef (s) 0.35 0.49 0.08 0.23 0.41 Direct assemble (ms) 387 634 170 338 458 DD assemble (ms) 103/50 199/23 121/28.6 155/31.8 119/20.9 Solve (s) 1.11 2.93 0.41 0.91 1.38

Table 3 reports the performance of our scaling optimization algorithm described in Section 7. Our optimization algorithm can robustly handle a large range of Von-Mises stresses, as in the bird model the maximal Von-Mises stress is dropped from 164.86 MPa to 55 MPa, reduced by 66.6%. For a model of tens of thousands of vertices, our optimizer is able to converge in tens of seconds. Fig. 9 shows the distributions of the per-element errors of two test models, which are estimated using the method described in Section 8. The bird model is a very ï¬ne model. The force conï¬guration and the analysis result is same as Fig. 7 (left), and the error of the whole mesh is 6.24% while the maximal element error is 127.3%. The horse model is relatively coarse. The force conï¬guration and the analysis result is same as Fig. 8 (middle), and the error of the whole mesh is 14.6% while the maximal element error is 338.5%. As most of our test models are relatively ï¬ne and quadratic elements are used, the estimated errors of our models are usually 5%â15%.

176

Y. Xie et al. / Computer Aided Geometric Design 35â36 (2015) 163â179

Table 3 The performance of scaling optimization. Max VM: the maximal Von-Mises stress of the model before optimization. Dopt : the number of the domains in Dopt . Cstr: the number of the vertices in Vconstrain when the optimization completes. For all these 3D models, we set the Von-Mises stress threshold as 55 MPa. Scene Opener Bird Horse Dinosaur Earphone Max VM (MPa) 89.95 164.86 91.40 110.62 87.83

Dopt
2 4 4 3 8

Cstr 3 4 3 2 7

Iter 6 10 6 6 9

Time (s) 20.78 77.89 9.55 18.89 52.90

Fig. 9. The distribution of the percentage error in energy norm on elements.

10. Conclusion In this paper, we described a shape editing system for models used in 3D printing. Our system integrates FEM simulation to provide stress distribution feedback during mesh editing. Domain decomposition is adopted as a uniï¬ed interface for shape editing, FEM system updating and shape optimization. Parametrization is used to eï¬ciently synchronize stiffness matrices with the edited mesh, and the FEM system is updated with a local update scheme to avoid repetitive computations. A domain-based scaling optimization algorithm is also devised to automatically reduce high stresses while preserving mesh shape. We tested our system with a variety of 3D models and veriï¬ed its accuracy with two physical experiments. The major limitation of our system is that it only supports the editing of skeleton-based models, and the editing interface is conï¬ned to domain-level translation, rotation and scaling. We are considering supporting more editing operations and parameterizing the stiffness matrix with more geometry parameters. In addition, our stiffness matrix parametrization only handles isotropic material. Therefore, integrating anisotropic material properties can be an interesting future work. In some large scale editing cases, we observe that large deformation may degenerate or even invert some tetrahedrons, which would downgrade the accuracy of the analysis or cause solver failure. Another possible future work can be to preserve qualities of the tetrahedral mesh or even apply re-meshing during mesh editing. Acknowledgements We would like to thank the anonymous reviewers for their constructive comments; Changke Zhang for improving the mesh quality. This work is partially supported by NSFC (No. 61272392, No. 61272305, No. 61322204). Yin Yang is partially supported by National Science Foundation CRII 1464306 and open project of State Key Lab of China of CAD&CG (A1403), and Xiaohu Guo is partially supported by Cancer Prevention & Research Institute of Texas (CPRIT) under Grant No. RP110329, and National Science Foundation (NSF) under Grant Nos. IIS-1149737 and CNS-1012975. Appendix A. Complete formulas in stiffness matrix parametrization In this appendix we list the complete formulas derived in Section 5. All the 9 elements of the sub-matrix Bi T DBj are:

(BiT DB j )00 =

â Ni â N j (1 â 2v ) â N i â N j (1 â 2v ) â N i â N j + + ) âx âx 2 ây ây 2 âz âz E â Ni â N j 1 â 2v â N i â N j (BiT DB j )01 = + ) (v (1 + v )(1 â 2v ) â x â y 2 â y âx
E

(1 + v )(1 â 2v )

((1 â v )

Y. Xie et al. / Computer Aided Geometric Design 35â36 (2015) 163â179

177

(BiT DB j )02 = (BiT DB j )10 = (BiT DB j )11 = (BiT DB j )12 = (BiT DB j )20 = (BiT DB j )21 = (BiT DB j )22 =

â Ni â N j 1 â 2v â N i â N j + ) âx âz 2 âz âx E â Ni â N j 1 â 2v â N i â N j + ) (v (1 + v )(1 â 2v ) â y â x 2 âx â y â Ni â N j E 1 â 2v â N i â N j 1 â 2v â N i + (1 â v ) + ( (1 + v )(1 â 2v ) 2 âx âx ây ây 2 âz E â Ni â N j 1 â 2v â N i â N j + ) (v (1 + v )(1 â 2v ) â y â z 2 âz â y E â Ni â N j 1 â 2v â N i â N j + ) (v (1 + v )(1 â 2v ) â z â x 2 âx âz E â Ni â N j 1 â 2v â N i â N j + ) (v (1 + v )(1 â 2v ) â z â y 2 â y âz â Ni E 1 â 2v â N i â N j 1 â 2v â N i â N j + + (1 â v ) ( (1 + v )(1 â 2v ) 2 âx âx 2 ây ây âz
E

(1 + v )(1 â 2v )

(v

âN j ) âz

âN j ) âz

(A.1)

So we can see the basic term in

Ë

Bi T DBj dxd ydz is

Ë
c(i , j , Î¸1 , Î¸2 ) =

â Ni â N j dxd ydz, âÎ¸1 âÎ¸2

Î¸1 , Î¸2 = x, y , z

(A.2)

As derived in Section 5, after handling the integration using (13) c(i , j , Î¸1 , Î¸2 ) can be expressed as

c(i , j , Î¸1 , Î¸2 ) = Î±(i , j ,Î¸1 ,Î¸2 ) m(Î¸1 ,Î¸2 )

(A.3)

where Î±(i , j ,Î¸1 ,Î¸2 ) is a constant coeï¬cient computed from the rest pose mesh, and m(Î¸1 ,Î¸2 ) is the term formed from scaling factor s x , s y and s z . To express Î±(i , j ,Î¸1 ,Î¸2 ) , we ï¬rst deï¬ne some helper functions. Let

i = mid(m, n)
express that the i-th node is the middle node between the m-th node and the n-th node (see Fig. 3), and

(A.4)

s (i , j ) =
and

1 10 1 20

if i = j if i = j

(A.5)

l(k,Î¸ ) =

bk ck dk

if Î¸ = x if Î¸ = y if Î¸ = z

(A.6)

where bk , ck and dk are computed as in (11). Then

â§4 âª s(i , j )l(i ,Î¸ )l( j ,Î¸ ) â 1 l(i ,Î¸ )l( j ,Î¸ ) âª 1 2 1 2 âª âª9 36 âª âª âª4 4 âª âª s âª âª 9 (n,q)l(m,Î¸1 )l( p ,Î¸2 ) + 9 s(m,q)l(n,Î¸1 )l( p ,Î¸2 ) âª âª âª âª âª âª âª + 4 s(n, p )l(m,Î¸1 )l(q,Î¸2 ) + 4 s(m, p )l(n,Î¸1 )l(q,Î¸2 ) âª âª âª 9 9 âª â¨ 4 1 Î±(i, j,Î¸1 ,Î¸2 ) = l l â l l s âª 9 (i ,q) (i ,Î¸1 ) ( p ,Î¸2 ) 36 (i ,Î¸1 ) ( p ,Î¸2 ) âª âª âª âª 1 âª + 4s âª l(i ,Î¸1 )l(q,Î¸2 ) âª (i , p ) l(i ,Î¸1 ) l(q,Î¸2 ) â âª 9 36 âª âª âª âª4 âª âª s(n, j )l(m,Î¸ )l( j ,Î¸ ) + 4 s(m, j )l(n,Î¸ )l( j ,Î¸ ) âª 1 1 2 2 âª9 âª 9 âª âª âª 1 âª â© â 1l l(n,Î¸1 )l( j ,Î¸2 ) (m,Î¸1 ) l( j ,Î¸2 ) â
36 36

if i , j â [1, 4] if i , j â [5, 10], and i = mid(m, n), j = mid( p , q) if i â [1, 4], j â [5, 10], and j = mid( p , q) if i â [5, 10], j â [1, 4], and i = mid(m, n) (A.7)

178

Y. Xie et al. / Computer Aided Geometric Design 35â36 (2015) 163â179

Finally, m(Î¸1 ,Î¸2 ) is expressed as:

m(Î¸1 ,Î¸2 ) =

â§ âª s2 s2 âª y z = s y sz âª âª sx s y s z sx âª âª âª âª 2 2 âª s s âª âª x z = sx s z âªs s s âª x y z sy âª âª âª 2 2 âª âª s s âª x y s s âª â¨s s s = x y s
x y z z

if Î¸1 = x, Î¸2 = x if Î¸1 = y , Î¸2 = y if Î¸1 = z, Î¸2 = z if Î¸1 = x, Î¸2 = y or Î¸1 = y , Î¸2 = x if Î¸1 = y , Î¸2 = z or Î¸1 = z, Î¸2 = y if Î¸1 = z, Î¸2 = x or Î¸1 = x, Î¸2 = z

âª s x s y s2 âª âª âª s s sz = s z âª x y z âª âª âª 2 âª âª sx s y s z âª âª âª sx s y s z = sx âª âª âª âª 2 âªs s s âª x y z âª â© s s s = sy
x y z

(A.8)

Appendix B. Supplementary material Supplementary material related to this article can be found online at http://dx.doi.org/10.1016/j.cagd.2015.03.019. References
Arnout, S., Firl, M., Bletzinger, K.-U., 2012. Parameter free shape and thickness optimisation considering stress response. Struct. Multidiscip. Optim. 45, 801â814. BÃ¤cher, M., Bickel, B., James, D.L., Pï¬ster, H., 2012. Fabricating articulated characters from skinned meshes. ACM Trans. Graph. 31 (4). http://dx.doi.org/ 10.1145/2185520.2185543. 47, 9 pp. BÃ¤cher, M., Whiting, E., Bickel, B., Sorkine-Hornung, O., 2014. Spin-it: optimizing moment of inertia for spinnable objects. ACM Trans. Graph. 33 (4), 96. Â´ Baran, I., Popovic, J., 2007. Automatic rigging and animation of 3d characters. ACM Trans. Graph. 26 (3). http://dx.doi.org/10.1145/1276377.1276467. BarbiË , J., Zhao, Y., 2011. Real-time large-deformation substructuring. In: ACM SIGGRAPH 2011 Papers. SIGGRAPHâ11. 91, 8 pp. c Bickel, B., BÃ¤cher, M., Otaduy, M.A., Lee, H.R., Pï¬ster, H., Gross, M., Matusik, W., 2010. Design and fabrication of materials with desired deformation behavior. ACM Trans. Graph. 29 (4). http://dx.doi.org/10.1145/1778765.1778800. 63, 10 pp. Bickel, B., Kaufmann, P., Skouras, M., Thomaszewski, B., Bradley, D., Beeler, T., Jackson, P., Marschner, S., Matusik, W., Gross, M., 2012. Physical face cloning. ACM Trans. Graph. 31 (4), 118. CalÃ¬, J., Calian, D.A., Amati, C., Kleinberger, R., Steed, A., Kautz, J., Weyrich, T., 2012. 3d-printing of non-assembly, articulated models. ACM Trans. Graph. 31 (6). http://dx.doi.org/10.1145/2366145.2366149. 130, 8 pp. Ceylan, D., Li, W., Mitra, N.J., Agrawala, M., Pauly, M., 2013. Designing and fabricating mechanical automata from mocap sequences. ACM Trans. Graph. 32 (6). http://dx.doi.org/10.1145/2508363.2508400. 186, 11 pp. Chen, D., Levin, D.I.W., Didyk, P., Sitthi-Amorn, P., Matusik, W., 2013. Spec2fab: a reducer-tuner model for translating speciï¬cations to 3d prints. ACM Trans. Graph. 32 (4). http://dx.doi.org/10.1145/2461912.2461994. 135, 10 pp. Chen, X., Zheng, C., Xu, W., Zhou, K., 2014. An asymptotic numerical method for inverse elastic shape design. In: Proc. of SIGGRAPH. ACM Trans. Graph. 33 (4). Coros, S., Thomaszewski, B., Noris, G., Sueda, S., Forberg, M., Sumner, R.W., Matusik, W., Bickel, B., 2013. Computational design of mechanical characters. ACM Trans. Graph. 32 (4). http://dx.doi.org/10.1145/2461912.2461953. 83, 12 pp. Deuss, M., Panozzo, D., Whiting, E., Liu, Y., Block, P., Sokrine-Hornung, O., Pauly, M., 2014. Assembling self-supporting structures. ACM Trans. Graph. 33. EPFL-ARTICLE-201940. Dong, Y., Wang, J., Pellacini, F., Tong, X., Guo, B., 2010. Fabricating spatially-varying subsurface scattering. ACM Trans. Graph. 29 (4). http://dx.doi.org/ 10.1145/1778765.1778799. 62, 10 pp. Dumas, J., Hergel, J., Lefebvre, S., 2014. Bridging the gap: automated steady scaffoldings for 3d printing. ACM Trans. Graph. 33 (4). http://dx.doi.org/ 10.1145/2601097.2601153. 98, 10 pp. Dutta, D., Prinz, F.B., Rosen, D., Weiss, L., 2000. Layered manufacturing: current status and future trends. J. Comput. Inf. Sci. Eng. 1 (1), 60â71. Farhat, C., Roux, F.-X., 1991. A method of ï¬nite element tearing and interconnecting and its parallel solution algorithm. Int. J. Numer. Methods Eng. 32 (6), 1205â1227. Farhat, C., Lesoinne, M., LeTallec, P., Pierson, K., Rixen, D., 2001. Feti-dp: a dualâprimal uniï¬ed feti method, part I: a faster alternative to the two-level feti method. Int. J. Numer. Methods Eng. 50 (7), 1523â1544. http://dx.doi.org/10.1002/nme.76. Hildebrand, K., Bickel, B., Alexa, M., 2012. Crdbrd: shape fabrication by sliding planar slices. Comput. Graph. Forum 31 (2pt3), 583â592. http://dx.doi.org/ 10.1111/j.1467-8659.2012.03037.x. Hu, R., Li, H., Zhang, H., Cohen-Or, D., 2014. Approximate pyramidal shape decomposition. In: Siggraph Asia 2014. Kim, T., James, D.L., 2011. Physics-based character skinning using multi-domain subspace deformations. In: Proceedings of the 2011 ACM SIGGRAPH/Eurographics Symposium on Computer Animation. SCAâ11, pp. 63â72. Koo, B., Li, W., Yao, J., Agrawala, M., Mitra, N.J., 2014. Creating works-like prototypes of mechanical objects. In: Proceedings of ACM SIGGRAPH Asia. ACM Trans. Graph. 33 (6). Article No. 217. Lan, Y., Dong, Y., Pellacini, F., Tong, X., 2013. Bi-scale appearance fabrication. ACM Trans. Graph. 32 (4). http://dx.doi.org/10.1145/2461912.2461989. 145, 12 pp. Lau, M., Ohgawara, A., Mitani, J., Igarashi, T., 2011. Converting 3d furniture models to fabricatable parts and connectors. ACM Trans. Graph. 30 (4). http:// dx.doi.org/10.1145/2010324.1964980. 85, 6 pp. Lu, L., Sharf, A., Zhao, H., Wei, Y., Fan, Q., Chen, X., Savoye, Y., Tu, C., Cohen-Or, D., Chen, B., 2014. Build-to-last: strength to weight 3d printed objects. In: Proc. SIGGRAPH. ACM Trans. Graph. 33 (4). 97, 10 pp. Liu, Y., Pottmann, H., Wallner, J., Yang, Y.-L., Wang, W., 2006. Geometric modeling with conical meshes and developable surfaces. ACM Trans. Graph. 25 (3), 681â689. http://dx.doi.org/10.1145/1141911.1141941.

Y. Xie et al. / Computer Aided Geometric Design 35â36 (2015) 163â179

179

Liu, Y.-J., Lai, K.-L., Dai, G., Yuen, M.-F., 2010. A semantic feature model in concurrent engineering. IEEE Trans. Autom. Sci. Eng. 7 (3), 659â665. Liu, Y., Xu, W., Wang, J., Zhu, L., Guo, B., Chen, F., Wang, G., 2011. General planar quadrilateral mesh design using conjugate direction ï¬eld. ACM Trans. Graph. 30 (6). http://dx.doi.org/10.1145/2070781.2024174. 140, 10 pp. Logan, D.L., 2012. A First Course in the Finite Element Method, ï¬fth edition. Cengage Learning. Luo, L., Baran, I., Rusinkiewicz, S., Matusik, W., 2012. Chopper: partitioning models into 3d-printable parts. ACM Trans. Graph. 31 (6), 129. McCrae, J., Singh, K., Mitra, N.J., 2011. Slices: a shape-proxy based on planar sections. ACM Trans. Graph. 30 (6). http://dx.doi.org/10.1145/2070781.2024202. 168, 12 pp. Mori, Y., Igarashi, T., 2007. Plushie: an interactive design system for plush toys. ACM Trans. Graph. 26 (3). http://dx.doi.org/10.1145/1276377.1276433. PrÃ©vost, R., Whiting, E., Lefebvre, S., Sorkine-Hornung, O., 2013. Make it stand: balancing shapes for 3D fabrication. In: Proceedings of ACM SIGGRAPH. ACM Trans. Graph. 32 (4). 81, 10 pp. Reprap, 2010. Open-source reprap project. http://reprap.org/wiki/RepRap. SchÃ¼ller, C., Panozzo, D., Sorkine-Hornung, O., 2014. Appearance-mimicking surfaces. ACM Trans. Graph. 33 (6), 216. Skouras, M., Thomaszewski, B., Coros, S., Bickel, B., Gross, M., 2013. Computational design of actuated deformable characters. ACM Trans. Graph. 32 (4). http://dx.doi.org/10.1145/2461912.2461979. 82, 10 pp. Stava, O., Vanek, J., Benes, B., Carr, N., MË ch, R., 2012. Stress relief: improving structural strength of 3d printable objects. ACM Trans. Graph. 31 (4). e http://dx.doi.org/10.1145/2185520.2185544. 48, 11 pp. Tao, J., Scott, S., Joe, W., 2005. Mean value coordinates for closed triangular meshes. In: Proceedings of ACM SIGGRAPH. Thomaszewski, B., Coros, S., Gauge, D., Megaro, V., Grinspun, E., Gross, M., 2014. Computational design of linkage-based characters. ACM Trans. Graph. 33 (4), 64. Toselli, A., Widlund, O., 2004. Domain Decomposition Methods. Springer. Umetani, N., Kaufman, D.M., Igarashi, T., Grinspun, E., 2011a. Sensitive couture for interactive garment modeling and editing. ACM Trans. Graph. 30 (4). http://dx.doi.org/10.1145/2010324.1964985. 90, 12 pp. Umetani, N., Takayama, K., Mitani, J., Igarashi, T., 2011b. A responsive ï¬nite element method to aid interactive geometric modeling. IEEE Comput. Graph. Appl. 31 (5), 43â53. Umetani, N., Igarashi, T., Mitra, N.J., 2012. Guided exploration of physically valid shapes for furniture design. ACM Trans. Graph. 31 (4). http://dx.doi.org/ 10.1145/2185520.2185582. 86, 11 pp. VidimË e, K., Wang, S.-P., Ragan-Kelley, J., Matusik, W., 2013. Openfab: a programmable pipeline for multi-material fabrication. ACM Trans. Graph. 32 (4). c 136, 12 pp. Wang, W., Wang, T.Y., Yang, Z., Liu, L., Tong, X., Tong, W., Deng, J., Chen, F., Liu, X., 2013. Cost-effective printing of 3d objects with skin-frame structures. In: Proc. SIGGRAPH Asia. ACM Trans. Graph. 32 (5). Article 177, 10 pp. Yang, Y., Xu, W., Guo, X., Zhou, K., Guo, B., 2013. Boundary-aware multidomain subspace deformation. IEEE Trans. Vis. Comput. Graph. 19 (10), 1633â1645. Zhou, Q., Panetta, J., Zorin, D., 2013. Worst-case structural analysis. ACM Trans. Graph. 32 (4). http://dx.doi.org/10.1145/2461912.2461967. 137, 12 pp. Zhu, L., Xu, W., Snyder, J., Liu, Y., Wang, G., Guo, B., 2012. Motion-guided mechanical toy modeling. ACM Trans. Graph. 31 (6). http://dx.doi.org/10.1145/ 2366145.2366146. 127, 10 pp. Zienkiewicz, O.C., Zhu, J.Z., 1987. A simple error estimator and adaptive procedure for practical engineering analysis. Int. J. Numer. Methods Eng. 24 (2), 337â357. Zienkiewicz, O., Taylor, R., Zhu, J., 2008. The Finite Element Method: Its Basis & Fundamentals. Elsevier.

