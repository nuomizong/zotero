DOI: 10.1111/j.1467-8659.2012.03230.x

COMPUTER GRAPHICS

forum

Volume 32 (2013), number 1 pp. 36â48

Vega: Non-Linear FEM Deformable Object Simulator
F. S. Sin,1 D. Schroeder1,2 and J. BarbiË 1 c

1 Department

of Computer Science, University of Southern California, CA, USA 2 Carleton College, MN, USA sinfunshing@gmail.com, dan5schroeder@gmail.com, jnb@usc.edu

Abstract This practice and experience paper describes a robust C++ implementation of several non-linear solid three-dimensional deformable object strategies commonly employed in computer graphics, named the Vega ï¬nite element method (FEM) simulation library. Deformable models supported include co-rotational linear FEM elasticity, SaintâVenant Kirchhoff FEM model, massâspring system and invertible FEM models: neo-Hookean, SaintâVenant Kirchhoff and MooneyâRivlin. We provide several timestepping schemes, including implicit Newmark and backward Euler integrators, and explicit central differences. The implementation of material models is separated from integration, which makes it possible to employ our code not only for simulation, but also for deformable object control and shape modelling. We extensively compare the different material models and timestepping schemes. We provide practical experience and insight gained while using our code in several computer animation and simulation research projects. Keywords: deformable objects, ï¬nite element method, non-linear, practice and experience, open source ACM CCS: I.6.8 [Simulation and Modelling]: Types of Simulation Animation I.3.5 [Computer Graphics]: Computational Geometry and Object ModellingâPhysically based modelling.

1. Introduction Researchers in physically based modelling have presented many three-dimensional (3D) non-linear deformable models and numerical timestepping schemes. A Google search, however, reveals that few of these models have publicly available implementations. Even when implementations are available, different authors tend to use different code conventions and organization, making it difï¬cult to evaluate and reuse the many ï¬nite element method (FEM) deformable strategies employed in computer graphics. In this practice and experience paper, we describe a C++ implementation of the most common FEM deformable models and timestepping schemes employed in computer graphics. We extensively compare the different deformable models and timestepping schemes to each other, and provide observations and insight for practical use. The code can simulate the dynamics of 3D solid deformable objects undergoing large deformations (see Figure 1), and optionally supports static deformations where the mass inertia is neglected. It is suitable both for ofï¬ine applications in ï¬lm, and real-time applications in games and virtual medicine. Our models are solid 3D volumetric meshes; we do not support shells or strands. Vega supports linear FEM elasticity, co-rotational linear FEM elasticity, the SaintâVenant
c 2012 The Authors Computer Graphics Forum c 2012 The Eurographics Association and Blackwell Publishing Ltd. Published by Blackwell Publishing, 9600 Garsington Road, Oxford OX4 2DQ, UK and 350 Main Street, Malden, MA 02148, USA.

Kirchhoff FEM model (isotropic geometrically non-linear elasticity), invertible FEM models (neo-Hookean, SaintâVenant Kirchhoff, MooneyâRivlin), as well as 3D massâspring systems. We provide several timestepping schemes, including implicit Newmark and backward Euler integrators and explicit central differences. We support tetrahedral meshes (with linear elements, Figure 2b) and cube hexahedral meshes (trilinear elements, Figure 2c), both of which are very common in computer graphics. Our simulator is a result of several years of research in computer animation and simulation, and we hope that it will ï¬nd usage in future research projects in these ï¬elds. The code is optimized for speed, well-commented and easy to modify. It supports CPU multicore computation of internal forces and stiffness matrices. Also supported are multi-core sparse linear system solves for implicit integration. Vega is released under the BSD open-source license, permitting free reuse by academia and industry. The code units depend minimally on each other and are independently reusable. For example, we separate internal elastic force computation from integration, so that, e.g., our massâspring system library can be used with any of our integrators, or the user can provide her own integrator. Similarly, any of our integrator libraries can timestep any

36

F. S. Sin et al. / Vega: Non-Linear FEM Deformable Object Simulator

37

terial model, has been employed in several papers [OH99, DDCB01, PDA01, CGCâ 02]. Specialized edge data structures have been presented to decrease the computation time of evaluating StVK internal forces [KTY09]. Co-rotational linear FEM was introduced to computer graphics in [MG04]. It can handle large deformations by extracting local material rotations using polar decomposition, and is a popular approach [PO09, CPSS10, MZSâ 11]. In simulations of soft tissue, common in computer graphics, mesh elements may invert during the simulation. Irving [ITF04] introduced material models that can restore from inversion, and Teran [TSIF05] showed how to compute the tangent stiffness matrix for such material models. Many papers then improved upon various aspects of these methods, for example, employing multi-grid [MZSâ 11], efï¬cient material coarsening [NKJF09, KMOD09] or performing the simulation in Eulerian coordinates [LLJâ 11]. Figure 1: Large FEM deformations: The crane voxel mesh is shown blended on top of the embedded triangle mesh, whereas the dragon uses the external surface of the tetrahedral mesh for rendering. Co-rotational, StVK and invertible FEM approaches are commonly used in computer animation practice. The OpenTissue [Ope] (ZLib license) and SOFA [SOF] libraries (LGPL) both offer linear and co-rotational FEM. OpenTissue also provides invertible corotational FEM internal forces (without stiffness matrices), ï¬nite differences and shape matching, whereas SOFA includes GPU computation, composite elements and multi-scale simulation. Whereas these libraries offer comprehensive solutions for deformations, plasticity, collision detection and rendering, our code is less complex and focuses on FEM deformable simulation and CPU multi-threading. Most models and integrators are implemented in a single {.h,.cpp} ï¬le pair, simplifying code reuse. To the best of our knowledge, Vega (BSD) is the only free library offering both internal forces and tangent stiffness matrices for linear, co-rotational, StVK and invertible FEM models. The Cubica [Kim] library (GPL) provides StVK and invertible FEM, as well as meshing and model reduction. Popular physics engines such as Bullet Physics [Cou], Havok [Hav] and Nvidia Phsyx [Phyb] do not support FEM, and typically model deformations using geometric shape matching [MHTG05]. The Physbam library [Phya] (BSD), while versatile and supporting many physical systems, currently does not support FEM solid deformable objects in its public release. Hyper-sim [Erl] is a Matlab library offering StVK, linear and co-rotational FEM. Commercial engineering (Abaqus [ABA]) and open-source (CalculiX [DW]) deformable object simulation tools can simulate large-deformation FEM models, but they do not support co-rotational or invertible models. Also, such engineering software was designed for scripted, ofï¬ine use, where the functionality to compute internal forces and stiffness matrices is built-in and not exposed to the end user.

Figure 2: Our simulator supports tetrahedral (b) and voxel meshes (c). The embedded triangle rendering mesh is shown in (a).

of our deformable models, or any physical system provided by the user. We provide documentation, compilation instructions, example meshes and a complete OpenGL application example. Vega can be downloaded at http://www.jernejbarbic.com/vega. 2. Related Work Deformable object simulation is a well-studied problem in computer graphics. We review the FEM approaches relevant to our paper; please see [NMKâ 06] for a general survey. In engineering, many papers discuss linear methods, which are limited to small deformations. One common approach to model large deformations is to employ quadratic GreenâLagrange strain (geometrically non-linear models). Its isotropic version, the St.VenantâKirchhoff (StVK) ma-

3. Overview For a detailed introduction to FEM deformable objects, we refer the reader to [Sha90, Bar07]. In solid mechanics, 3D deformable objects are modelled by the non-linear partial differential equations of elasticity. After applying FEM, one obtains an ordinary differential equation, Â¨ Ë M u + D u + fint (u) = fext (t), (1)

where u â R3n contains the displacements of the n mesh vertices away from the rest conï¬guration, M â R3nÃ3n is the mass matrix, Â¯ D = Î±M + Î²K(u) + D is the damping matrix, fint (u) â R3n are

c 2012 The Authors Computer Graphics Forum c 2012 The Eurographics Association and Blackwell Publishing Ltd.

38

F. S. Sin et al. / Vega: Non-Linear FEM Deformable Object Simulator

Figure 3: Implementation overview: Solid lines denote class derivation, dashed lines denote that a class serves as input to another class. the internal elastic forces and fext (t) â R3n are external forces (e.g. gravity, wind, contact, user forces). The gradient of fint (u) with respect to u,K(u) = âfint (u)/âu â R3nÃ3n , is called the tangent stiffness matrix. Equation (1) covers many deformable models used in computer graphics, including FEM deformable models, cloth and massâspring systems. Scalar parameters Î± and Î² and matrix Â¯ D â R3nÃ3n control damping: Î± sets the level of âmassâ damping (slows down deformations globally, as in underwater damping), Î² sets the âstiffnessâ damping (damps primarily any relative deformation velocity differences; useful to remove temporal high-frequency Â¯ instabilities) and D is an additional damping matrix that can optionÂ¯ ally be set by the user. For D = 0, we obtain the familiar Rayleigh damping [Sha90]. A deformable object simulator must timestep Equation (1) forward in time, under some user-provided initial and boundary conditions. Initial conditions include the initial position and velocity of the deformable object. For boundary conditions, the user typically selects an arbitrary set of ï¬xed vertices, that is, vertices whose deformation is zero at all times. The simulator must incorporate the ability to store 3D volumetric meshes, including their (potentially spatially varying) material properties. It must also provide the ability to calculate matrices M, D, K(u) and internal forces fint (u). There is a certain degree of independence in these tasks. Calculation of internal forces does not depend on the speciï¬c numerical integration scheme to timestep Equation (1), and vice versa. Integrators do not depend on the type of the volumetric mesh. These observations motivated the design of our Vega library, which provides all of these components, and exposes and exploits independence. Our C++ classes can be divided into three groups (Figure 3): (1) volumetric mesh containers (green), (2) internal forces calculators (red) and (3) integrators (blue). Each of the classes is a standalone unit that can be reused independently of the rest of the code.

Volumetric mesh containers store the 3D locations of the mesh vertices in the undeformed conï¬guration, element connectivity and the material properties of each element. Our classes support operations such as loading and saving a mesh to a ï¬le, calculating mesh volume, centre of mass, inertia tensor and mesh mass matrix, identifying mesh elements neighbouring a vertex and interpolating vertex deformations to a higher-resolution embedded rendering mesh. Such interpolation is very useful in practice as it makes it possible to drive a detailed triangle mesh with a coarse simulation [JBT04, MTG04]. We interpolate using the CPU, but a GPU implementation would also be possible. The material properties (Youngâs modulus, Poissonâs ratio and mass density) may be deï¬ned per element. Alternatively, subsets of the elements can be deï¬ned, and then the properties are applied commonly to all the elements in a subset. In order to specify the 3D geometry and support such material properties, Vega introduces an ASCII ï¬le format .veg, extended from the familiar free 3D mesh geometry format of Jonathan Shewchuk and used by the TetGen 3D mesher [Han11]. We also provide a routine to compute the (consistent, non-lumped) mass matrix M, which can be lumped to a diagonal matrix if so desired (more on lumping in Section 7). Internal force and stiffness matrix calculators evaluate the internal forces fint (u) and tangent stiffness matrices K(u) for all the material models stated in the Introduction, for any deformation u. Our classes are: CorotationalLinearFEM StVKInternalForces StVKStiffnessMatrix IsotropicHyperelasticFEM MassSpringSystem Each class is initialized by providing a volumetric mesh and the parameters needed for the material model. Some materials (massâspring system, SaintâVenant Kirchhoff) support both tet and cube meshes, while others were only designed for tet meshes [MG04, ITF04, TSIF05]. The resulting internal forces and stiffness matrices can be timestepped with any numerical scheme, either one provided by our code, or any other timestepping scheme of choice. In order to establish a common interface to our integrators, we standardize access to the different material models through the âSparseInternalForceModelâ abstract base class. This âblack-boxâ class merely deï¬nes the following two abstract virtual functions: virtual void GetInternalForce(double â u, double â internalForces) = 0; virtual void GetTangentStiffnessMatrix ( double â u, SparseMatrix â tangentStiffnessMatrix) = 0; For each of our material classes, we then provide a short wrapper class that derives from SparseInternalForceModel, and that implements the above functions by calling the functions in the material class. For example, MassSpringForceModel derives from SparseInternalForceModel, and is implemented by calling functions from the MassSpringSystem class. Such a construction is very useful in practice because it decouples the integrators from the material models. Our integrators work simply with a pointer to the abstract base class âSparseInternalForceModeâ, exploiting C++ virtual derivation polymorphism, and are completely agnostic of the speciï¬c material model implementation. Similarly, material models

c 2012 The Authors Computer Graphics Forum c 2012 The Eurographics Association and Blackwell Publishing Ltd.

F. S. Sin et al. / Vega: Non-Linear FEM Deformable Object Simulator

39

need not be aware of integrators and are implemented free of any integration-related code, making it possible to use the internal forces and stiffness matrices for any general purpose, for example, inverse kinematics or optimization. Integrators timestep a deformable object (or any other physical system) forward in time. They obtain internal forces and stiffness matrices from an instance of a SparseInternalForceModel class. Our integrator classes are: ImplicitNewmarkSparse ImplicitBackwardEulerSparse CentralDifferencesSparse EulerSparse Support classes: In addition to the âcoreâ classes described, Vega also includes classes to store and perform arithmetics on sparse matrices, load and store obj meshes, render deformed obj meshes using OpenGL, measure C++ code execution time and parse customdeï¬ned conï¬guration ï¬les. In order to facilitate code re-use, we provide a demo application, which allows the user to pull on a mesh with the mouse and see the resulting dynamic deformations in real-time. Free-ï¬ying objects: Without any ï¬xed vertices, the object possesses free rigid degrees of freedom in addition to the deformations, which causes the stiffness matrix K to be singular. The dimension of the nullspace of K equals the number of free rigid degrees of freedom, which is six if no vertices are constrained, and less depending on what vertices are constrained. For example, if only one vertex is constrained, the object will be able to freely rotate around that vertex (three free degrees of freedom; nullspace of K will consist of all inï¬nitesimal rotations). By constraining at least three vertices that do not lie on the same line, all rigid degrees of freedom can be removed. In practice, however, we usually constrain more than three vertices if the intent is to remove all rigid degrees of freedom. We note that our dynamic simulations remain stable even for deformable objects that simultaneously undergo both free-ï¬ying rigid motion and deformations. Namely, the linear system that must be solved at each timestep under implicit integration, is a weighted sum of the mass matrix, damping matrix and stiffness matrix, with integratordependent, positive weights. The presence of the mass and damping matrix terms shifts the system eigenvalues in a positive direction, which regularizes the system. Overview simulation times are given in Table 1 (singleprocessor six-core 3.33 GHz Intel i7 CPU with 9GB RAM running Ubuntu Linux 11.04). More detail is provided in Tables 2â4. All our simulations use semi-implicit integration, that is, performing a single step of the NewtonâRaphson relaxation procedure at every timestep [BW98]. 4. Elastic Materials We now describe our supported deformable models: co-rotational linear elasticity, standard SaintâVenant Kirchhoff, invertible neoHookean and invertible SaintâVenant Kirchhoff models, and comment on their strengths, weaknesses and practical performance. Ultimately, each of these materials results in an implementation of the âGetInternalForceâ and âGetTangentStiffnessMatrixâ routines (Section 3), and can then be used with any of our integrators. Table 2 gives a speed comparison of the supported deformable models.

4.1. Co-rotational linear elasticity The co-rotational linear elasticity FEM model [MG04] is a very popular solid 3D non-linear deformable model in computer graphics. Purely linear models result in inï¬ated volume artefacts under large deformations. The co-rotational model removes linearization artefacts, by assuming that the deformation, at every element in the mesh, consists of a rotation plus a small amount of âpureâ deformation. The rotation is determined via polar decomposition of the deformation gradient F . Once the rotation is identiï¬ed, the forces on an element are computed based on only the âpureâ deformation, and properly rotated to the world frame of reference. Our implementation supports tet meshes, and includes a polar decomposition library. Optionally, the caller can disable âwarpingâ, which yields a standard linear FEM model, with a constant stiffness matrix K, and internal forces f lin = Ku. Speciï¬cally, our code implements the following calculation. In the standard (i.e. non-warped) linear model, the 12-dimensional vector felin = Ke ue of vertex forces of an element e is a linear function of the element stiffness matrix Ke â R12Ã12 and the dis0 placement ue = xe â xe â R12 of its vertices from their rest position 0 12 xe â R . After calculating the rotational component Re of the element deformation gradient using polar decomposition, one assemË bles a 12 Ã 12 block-diagonal matrix Re , with four 3 Ã 3 blocks Re . One then obtains co-rotational vertex forces by applying Ke to the rotation-cancelled deformations, followed by a rotation,
0 Ë ËT fe = Re Ke (Re xe â xe ) T 0 Ë Ë ËT Ë = Re Ke Re ue + Re Ke (Re â I )xe .

(2)

Note that for ue = 0, we have Re = I , and fe = 0, as expected. For implicit integration, we use a stiffness matrix assembled from ËT Ë the warped stiffness matrices Re Ke Re of each tetrahedron, which is a very common choice in computer graphics [MG04, PO09]. Although this choice in practice gives stable simulations (except in cases of extreme velocities), we note that this matrix is not ËT Ë the exact gradient of the internal forces (dfe /due = Re Ke Re ), because the gradients of Re with respect to ue are ignored. This limitation has been recently addressed by [CPSS10] and [Bar12]; an implementation is available in Vega. All experiments ËT Ë in this paper refer to the approximate stiffness matrix Re Ke Re [MG04].

4.2. SaintâVenant Kirchhoff elasticity The SaintâVenant Kirchhoff material model is another commonly employed deformable model in computer graphics. It uses nonlinear GreenâLagrange strain E = 1/2(F T F â I ), which ensures that the model is free of large rotation artefacts. StVK is perhaps the simplest non-linear model, because it models the stressâstrain relationship with a linear function. Unlike general linear materials which can be anisotropic, StVK has the additional property that it is isotropic, and is therefore sometimes referred to as the isotropic geometrically non-linear material model. Because of all of these assumptions, StVK can be parametrized by only specifying two scalar values. Two representations are commonly employed and supported by our code: the LamÂ´ coefï¬cients Î», Î¼ and the Youngâs e modulus and Poissonâs ratio E, Î½. StVK is given by the energy

c 2012 The Authors Computer Graphics Forum c 2012 The Eurographics Association and Blackwell Publishing Ltd.

40

F. S. Sin et al. / Vega: Non-Linear FEM Deformable Object Simulator

Table 1: Simulation statistics: T = tet mesh, V = voxel mesh, #vertices (#ver), #elements (#el), total dynamics time (total; includes internal forces and stiffness matrix evaluation and integrator time, as separately reported in Tables 2 and 3), #simulation steps per rendered frame (N ), #vertices in rendering mesh (#Rver), #triangles in rendering mesh (#Rtri), time to interpolate deformations from volumetric to triangle mesh for rendering (interp), time to dynamically recompute the mesh normals for rendering (normals), and the overall achieved frame rate (fps), using OpenGL, with dynamically recomputed normals. The dragon interpolation time is zero, because that model uses the outer surface of the volumetric mesh as the rendering mesh. All timings are in milliseconds per timestep, using a single core, for the StVK material model integrated with implicit Newmark.

#ver Dinosaur (T) Bridge (V) Bridge (T) Crane (V) Dragon (T) 344 3923 4000 9875 46 736

#el 1031 1736 12 827 5571 160 553

total (ms) 39.7 480 361 1574 6783

N 2 8 8 2 1

#Rver 28 098 16 085 16 085 149 797 46 736

#Rtri 56 192 16 616 16 616 260 187 77 250

interp (ms) 0.8 0.4 0.3 8.1 0

normals (ms) 21.7 8.1 8.3 99.1 23.1

fps 13.2 1.9 2.4 0.5 0.1

Table 2: Internal force (INT) and stiffness matrix (STM) evaluation times, in milliseconds per timestep, using a single core. Co-rotational FEM timings are reported total for INT + STM, because they cannot easily be separated in the implementation.

StVK Co-rotational linear FEM Dinosaur Bridge (V) Bridge (T) Crane Dragon 2.1 â 32.1 â 484 INT 14.5 136 99.8 443 1219 STM 18.5 256 191 828 2737

Invertible StVK INT 0.1 â 0.8 â 15.5 STM 3.5 â 40.1 â 582

Invertible Neo-Hookean INT 0.1 â 1.6 â 21.2 STM 3.2 â 41.3 â 599

Massâspring system INT 0.1 1.2 0.8 3.1 17.1 STM 0.3 5.3 4.1 20.1 70.8

density function (see [BW08]) = 1 Î»(tr(E))2 + Î¼E : E. 2 (3)

It can be shown that the StVK elastic energy is a quartic (4th order) polynomial in the deformations of the mesh vertices (see, e.g. [CGCâ 02, Bar07]). Therefore, the internal forces and the tangent stiffness matrix are cubic and quadratic polynomials, respectively. The coefï¬cients of these polynomials can be derived analytically, using integration of FEM shape functions over each element. They are given in [CGCâ 02, Bar07]. With general deformable models, such integration can only be performed numerically. One advantage of StVK is that the integration can be performed exactly during pre-computation, with a negligible computational overhead. We performed the integration analytically in Mathematica for both tets (of arbitrary shapes) and cubes, and transferred the formulas to efï¬cient C code. Our StVK implementation is then immediately loadable and requires only a small memory footprint to store the cubic polynomial coefï¬cients. Because the StVK internal forces are cubic polynomials, it is very easy to compute, analytically, the exact StVK tangent stiffness matrix, and even further derivatives. Our code provides the StVK stiffness matrix and also its derivative (the Hessian of the internal forces). Such highorder derivatives are useful in applications involving optimization and control of deformable models, as they make it possible to use higher-order optimization schemes. Furthermore, the cubic polynomial formula is useful in model reduction [BJ05], because linear projections to low-dimensional spaces commute with any polynomial expression.

We observe two disadvantages of StVK. First, under large compression, the material collapses, and may even permanently invert. This problem generally applies to soft tissue; stiffer models are less prone to collapse. To address invertibility, we provide an invertible StVK implementation (Section 4.3). The second disadvantage of a cubic polynomial-based StVK implementation is that, although exact, the number of cubic polynomial terms is quartic in the degrees of freedom of the element (see Table 2). Therefore, the evaluation of internal forces is slower with StVK than, say, with co-rotated linear models. Note that for tetrahedral elements, one may use the invertible StVK method of Section 4.3, which is faster (see Table 2) and gives identical results to standard StVK when the correction of inverted elements is disabled. The invertible FEM approach, however, cannot easily give stiffness matrix derivatives (Hessians). We note that if invertibility is not needed, it would be possible to gain further speed in StVK (for tet meshes) by computing the ï¬rst-Piola Kirchoff stress tensor P (Section 4.3), and analytically differentiate it with respect to F (avoiding SVD); we leave this extension for future work. We compare the stretching behaviour of co-rotational linear FEM to StVK in Figure 4. It can be seen that the two materials behave quite differently under large deformations. Under small deformations, however, the two materials are visually similar (see Figure 5, bottom). 4.3. Invertible element methods The material models above share the limitation that if a tet becomes inverted due to extreme deformation, the internal forces do not act to restore the tet to an uninverted state. The invertible model [ITF04] addresses this weakness by calculating material stress using the

c 2012 The Authors Computer Graphics Forum c 2012 The Eurographics Association and Blackwell Publishing Ltd.

F. S. Sin et al. / Vega: Non-Linear FEM Deformable Object Simulator

41

Figure 4: Material behaviour under stretching: (a and b) cantilever beam at rest, with tets and cubes. Pulling end of beam: (c) co-rotational linear FEM with tets, (d) linear FEM with cubes, under the same forces as c, (e and f) StVK, under the same forces as c, (g and h) StVK, stretched to the same length as c. Applying gravity: (i and j) StVK, under same total force as c. Poissonâs ratio was 0.45. Because there are almost no local rotations, (c) and (d) coincide, and internal forces are linear in displacement. StVK, however, stiffens non-linearly. Volumetrically distributed loads (gravity) produce smaller displacements than concentrated loads. singular value decomposition (SVD) of the deformation gradient F , where inversion is easily detected. The vertex forces on a deformed tet rotate with the tet if the tet is rotated in world space. For isotropic materials, the forces are similarly invariant with respect to rotations in material space, so the ï¬rst PiolaâKirchhoff stress P (F ), viewed as a function of F , satisï¬es Ë Ë P (U FV T ) = UP(F )V T ,
T T

(4)

Ë Ë where F = U FV , and U and V are rotations such that F is diagonal. One can now determine that the tet is near-inverted if one of Ë the diagonal entries Î»1 , Î»2 , Î»3 of F is below a small positive threshold, and clamp such entries to that threshold to produce forces that restore the tet. We found such clamping to work well in practice. Ë For stress deï¬ned by an energy function , it can be shown that F yields diagonal stress Ë P (F ) = diag â â â , , âÎ»1 âÎ»2 âÎ»3 . (5)

Figure 5: Mesh reï¬nement: Top: we simulate the same solid object (bridge), under progressive, non-nested, tet mesh reï¬nement. The L0 mesh (4000 / 12 827 vertices/tets) is also reported in Table 1 and Figure 8. L1 and L2 meshes have 20 921 / 83 566 and 106 827 / 477 589 vertices / tets, respectively, and mesh approximately the same volume as the L0 mesh. Same timestep, initial velocity, material properties, damping and plotted vertex as in Figure 8. It can be seen that ï¬ner simulations produce richer dynamic motion. Bottom: StVK versus co-rotational linear FEM.

The values â /âÎ»i can be computed analytically by differentiating the energy function of any standard isotropic material model, or they could even be measured experimentally. Once we calculate P (F ) Ë from P (F ), we obtain the force on a vertex of the tet by multiplying P (F ) with its area-weighted normal (see [ITF04] for details). Implicit timestepping methods require the stiffness matrix for the invertible model. Such a stiffness matrix was derived in [TSIF05], and we implement this method in Vega. Using the diagonalization as in Equation (5), we calculate the entries of the gradient of the stress with respect to F as âP =U âFij âP âF : (U T (ei â ej )V ) V T ,
UT FV

Figure 6: Our invertible simulator can recover from extreme deformations (invertible StVK): (A) collapsed (initial condition), (B) partially recovered (intermediate state), (C) completely recovered (ï¬nal state). where ei is the ith standard basis vector in R3 . The gradient evaluated at U T FV can be calculated as a function of the Î»i and the gradient and Hessian of with respect to the invariants of C = F T F (for more details, please refer to [TSIF05]). The invertible FEM models in Vega are able to recover very well from extremely inverted conï¬gurations (see Figure 6).

(6)

c 2012 The Authors Computer Graphics Forum c 2012 The Eurographics Association and Blackwell Publishing Ltd.

42

F. S. Sin et al. / Vega: Non-Linear FEM Deformable Object Simulator Table 3: Integrator times: IBE = implicit backward Euler, IN = implicit Newmark, ECD = explicit central differences, EE = explicit Euler. All timings are in milliseconds per time step, using a single core. They include the entire time step computation, except internal force and stiffness matrix evaluation. For implicit integration and central differences, they include the Pardiso linear system solver time. Central differences were timed using a constant pre-factored system matrix.

Invertible SaintâVenant Kirchhoff material adds invertibility to the StVK material model given in Section 4.2. We ï¬rst rewrite the energy density from Equation (3) in terms of the invariants of C = FT F : = 1 Î»(IC â 3)2 + 1 Î¼(I I C â 2IC + 3). 8 4 Invariants are deï¬ned as follows [BW08]: IC = tr(C) = Î»2 + Î»2 + Î»2 , 1 2 3 II C = tr(C 2 ) = Î»4 + Î»4 + Î»4 , 1 2 3 III C = det(C) = Î»2 Î»2 Î»2 . 1 2 3 (8) (9) (10) (7)

IBE Dinosaur Bridge (V) Bridge (T) Crane Dragon 5.29 90.3 73.9 339 2856

IN 6.70 87.0 70.0 303 2827

ECD 1.36 20.1 19.0 53.8 239

EE 0.67 9.54 9.81 25.0 110

We then analytically differentiate energy (Equation 7) with respect to the invariants (ï¬rst and second derivative), and then apply these formulae to our implementation of [TSIF05] (Section 4.3). Invertible Neo-Hookean material uses the energy density function (page 162 in [BW08]) Î» Î¼ = (IC â 3) â Î¼ log J + (log J )2 , 2 2 â where Î¼ and Î» are the LamÂ´ coefï¬cients, and J = IIIC . e (11)

such that particle a receives force f (z) and particle b receives âf (z). We compute damping forces in a similar way. To enable implicit integration, we calculate the gradient of f as âf = ks âz 1â r r I+ zzT , |z| (|z|)3 (14)

from which we obtain the contribution of each spring to the global stiffness matrix. We also derive and implement the derivative of the stiffness matrix (Hessian). 5. Integrators We support several explicit and implicit integration methods (see Table 3 for a speed comparison). All the methods timestep the ODE given in Equation 1. Except with soft objects, FEM deformable simulations are very stiff and require implicit integration with large timesteps. For explicit integration, the required timestep is imposed by the smallest element in the mesh (Courant condition). 5.1. Implicit backward Euler Given deformations ut and velocities vt at time t, the implicit backward Euler method [BW98] attempts to ï¬nd a future deformation ut+ t such that explicitly integrating at time t with forces fint (ut+ t ) evaluated at t + t will produce the same deformation ut+ t . If we let u = ut+ t â ut and v = vt+ t â vt represent the changes in deformation and velocity from time t to t + t, then we want to set u = t v v + vt M â1 (âDvt+
t

Invertible MooneyâRivlin material uses the energy density function (see Section Ã3.5.5 in [Bow09]) I 2 â I IC 1 = Î¼01 C 4/3 â 6 + Î¼10 2 J + v1 (J â 1)2 , IC â3 J 2/3 (12)

where Î¼01 , Î¼10 , v1 are MooneyâRivlin material parameters. Arbitrary isotropic hyperelastic materials are supported by Vega, via C++ class polymorphism. One simply has to provide a class that derives from a standardized Vega abstract base class for isotropic materials, and that evaluates the ï¬rst and second derivatives of the energy density with respect to IC , II C , III C . 4.4. Massâspring system The massâspring system model simulates a set of particles connected by springs [BW01]. Each particle can have its own mass; similarly, different springs can have different stiffness and damping coefï¬cients, as well as rest lengths. We support general massâspring networks; there is no restriction on which particles are connected by springs. To facilitate the creation of a massâspring network, we provide a routine which converts a tet mesh into a massâspring system: vertices become particles, and each tet edge serves as a spring. Similarly, one can convert a cube mesh into a massâspring network: all 12 cube edges become springs, along with the 12 face diagonals and the 4 main diagonals. We compute spring forces using the standard Hookeâs law for springs. For a spring of rest length r and stiffness ks between particles at positions a and b = a + z, the spring force is z (13) f (z) = ks (|z| â r) , |z|

â fint (ut+ t ) + fext )

.

(15)

To ï¬nd approximate solutions when fint is non-linear, we substitute a Taylor series approximation of fint (ut+ t ), computed using the tangent stiffness matrix K = âfint /âu (semi-implicit integration). This gives the linear equation (M + = tD + ( t)2 K) v t(fext â fint (ut ) â ( tK + D)vt ). (16)

After solving Equation (16) for v, we can calculate u from Equation (15). Such semi-implicit backward Euler is not unconditionally stable, unlike fully implicit backward Euler where the non-linear

c 2012 The Authors Computer Graphics Forum c 2012 The Eurographics Association and Blackwell Publishing Ltd.

F. S. Sin et al. / Vega: Non-Linear FEM Deformable Object Simulator

43

Equation (15) is solved exactly. Such an exact solver is largely only a theoretical concept, however, as in practice, ï¬nding the required exact solution can only be done via a full NewtonâRaphson relaxation at every timestep. This search may diverge if the initial guess is too far from the exact solution. Consequently, both semi-implicit and fully implicit integration can become unstable under very large timesteps. In practice, however, semi-implicit backward Euler is a reasonable choice; it is both simple and very stable. Its main drawback is that it tends to introduce signiï¬cant artiï¬cial damping with large timesteps. 5.2. Implicit Newmark The implicit Newmark integrator is very popular in solid mechanics, mainly because of its quadratic-order timestep accuracy [Woo90]. In practice, it is slightly less stable than implicit backward Euler, but produces more lively animations with less artiï¬cial damping. Given current deformations ut , velocities vt , and accelerations at at time t, the implicit Newmark method [Wri02] assumes that the future deformations, velocities and accelerations ut+ t , vt+ t , at+ t satisfy ut+ vt+
t t

Table 4: Comparison of sparse solvers: Two direct solvers (Par = Pardiso, SPO = SPOOLES) are compared to an iterative solver (PCG; Jacobi-preconditioned conjugate gradients). Timings are in milliseconds per time step, using a single core. PCG uses zero initial guess and stops when the residual norm drops below = 10â6 times the initial residual norm. Multi-core scalability and the dependence of running time on material stiffness are investigated in Figure 11.

Time (ms) Par Dinosaur Crane Bridge (T) Bridge (V) Dragon 5.1 308 72 73 2821 SPO 16.4 566 136 133 5039 PCG 4.6 1012 9.1 13.3 8934 Par 1.3 59.5 16.5 19.3 289

Memory (Mb) SPO 1.1 62.2 16.2 18.9 320 PCG 0.03 0.90 0.36 0.36 4.3

= ut + = vt +

( t)2 ((1 â 2Î²)at + 2Î²at+ t ), 2 (17) t((1 â Î³ )at + Î³ at+ t ), t Â· vt +

Table 4. In most cases, direct solvers outperform PCG in computation time, but require more memory. Direct solver times do not depend on material stiffness (Youngâs modulus), whereas the number of required PCG iterations is proportional to stiffness (see also Section 7). Therefore, PCG is a better alternative to direct solvers with soft objects, and with large systems where the direct factorization may not ï¬t into memory.

where 0 â¤ Î² â¤ 0.5 and 0 â¤ Î³ â¤ 1 are user-chosen parameters. In practice, these values are often set to Î² = 0.25 and Î³ = 0.5, which gives second-order accuracy. To satisfy the above equations, we solve for at+ t and vt+ t in terms of ut+ t and the known values at time t. Inserting the results into Equation (1), we obtain a non-linear equation for ut+ t : G(ut+ t ) = M 1 1 1 â 2Î² vt â at (ut+ t â ut ) â Î²( t)2 Î² t 2Î² Î³ Î³ Î³ (ut+ t â ut )+ 1 â vt + 1 â t Â· at +D Î² t Î² 2Î²
t

5.3. Central differences The central differences integrator [Wri02] is the explicit companion to the implicit Newmark integrator. It typically requires much smaller timesteps than implicit Newmark, and is useful in simulations that must take very small timesteps, for example, simulations involving transient contact or sound simulations. The update equation is M+ t D (ut+ 2
t t

â ut ) = ( t)2 (fext â fint (ut )) (20)

+ fint (ut+ t ) â (fext )t+

= 0.

(18)

+

t D(utâ 2

â ut ) + M(ut â utâ t ) â ut . t

To solve for ut+ t , we start with u0 t = ut . We then perform a t+ NewtonâRaphson procedure, iteratively generating updated guesses ui+1 t , by using the stiffness matrix and fint at the current guess t+ ui t : t+ 1 âfint Î³ D+ M+ Î²( t)2 Î² t âu = âG(ui t ), t+ where ui+1 t = ui t + ui+1 t . We halt the process when G(ui t ) t+ t+ t+ t+ falls below a desired accuracy threshold, or after exceeding a maximum number of iterations. Sparse linear solvers are required for implicit integration. Vega employs three solvers: Pardiso (commercial; direct; by the Pardiso Project and Intel [PAR]), SPOOLES (free; direct; by Boeing [SPO]) and our own Jacobi-preconditioned conjugate gradient (PCG) implementation (free; iterative; released with Vega), which we implemented by following [She94]. We give a timing comparison in ui+1 t t+

vt+

t

=

ut+

t

(21)

u=ui t t+

(19)

A central differences timestep is faster than the implicit Newmark timestep because there is no need to construct the tangent stiffness matrix. Furthermore, if the damping matrix D does not vary through time, the matrix M + 2t D can be pre-factored. For Rayleigh damping, however, the matrix D(u) = Î±M + Î²K(u) varies in time. While it is tempting to ignore the dependency of K on u and simply use a constant stiffness matrix K = K(0) for damping, we observed that this leads to very visible damping artifacts under large deformations. A reasonable alternative to using exact K(u) is to periodically recompute K(u) and refactor M + 2t D(u). Explicit Euler: We also provide explicit and symplectic Euler integrators. Symplectic Euler [SD06] preserves energy and is typically more stable than explicit Euler.

c 2012 The Authors Computer Graphics Forum c 2012 The Eurographics Association and Blackwell Publishing Ltd.

44

F. S. Sin et al. / Vega: Non-Linear FEM Deformable Object Simulator

Figure 7: CPU multi-core scalability: INT, internal forces; STM, stiffness matrix; SO, solver time; TOT, total time. Bridge example with tets, StVK material, Pardiso solver, implicit backward Euler. Single-processor six-core 3.33 GHz Intel i7 CPU with 9GB RAM. Both INT+STM and solver can be seen to scale well to a few cores, with diminishing returns for many cores. INT+STM evaluations are more parallel and scale better than Cholesky decomposition and back-substitution inside direct sparse solvers. ITM + STM scalability is affected by contention to read the vertex displacements from memory, and the overhead of launching the treads.

Figure 8: Timestep reï¬nement: We simulated the L0 bridge tet mesh (Figure 2b, and Table 1, StVK, Î½ = 0.45, 4000 vertices; small user damping), under progressive timestep reï¬nement. All simulations use the same initial velocity, followed by free vibration. We plot the trajectory of a vertex at the top of the bridge mast. Under a large timestep (denoted by 1Ã), numerical viscosity due to implicit integration is high, causing a rapid loss of energy. The rate of energy loss decreases as the deformations become smaller. Numerical viscosity is smaller under smaller timesteps. Smaller timesteps also produce greater dynamic detail. For scale: the height of the bridge is 3 units. Z-axis is perpendicular to the main bridge axis, and the mast.

6. CPU Multi-Core Implementation We provide a CPU multi-core implementation for all our material models, for both the internal forces and stiffness matrices. The implementation is available in classes with extension âMTâ that derive from a single-core version of the class, for example, âStVKInternalForcesMTâ is derived from âStVKInternalForcesâ. The user provides the desired number of computation threads T to the âMTâ constructor. The routine to compute the internal forces then launches T threads, using the pthreads API (available on Linux, Mac OS X and Windows). The set of all mesh elements is divided into T âbucketsâ, each of which is assigned to a thread. Each thread then processes its elements. For each element, it computes the internal forces, and then adds the forces into its own, separate, internal force buffer. This avoids write-conï¬icts, and removes the need for any thread synchronization. The buffers are of length 3n, static, allocated once in the constructor, and cleared to zero by the thread at the beginning of each computation. After all threads are ï¬nished, the main thread sums the buffers into a total internal force. We use an equivalent procedure for stiffness matrices. The Pardiso and SPOOLES solvers support multi-threading, and we wrote wrappers where we can conveniently set the number of solver threads. In practice, solver scalability is good for 2â3 cores, but diminishes with more cores. Figure 7 analyses the performance of our multi-core implementation. In our implementation, we launch and kill the threads each time internal forces or stiffness matrices are computed. The advantage of this approach is that it leaves room for other (non-simulation) tasks to be mapped to the different cores. Because there is some OS overhead in launching the threads, our threading stops becoming useful with very small models, for example, when the running time of each thread would be less than approximately 10 ms. This is especially pronounced with massâspring systems where the internal force computation times are short. It would be easily possible to modify our code so that the threads are launched once and then persist, spinning idle on a mutex until needed. Note that the threads cannot be made to sleep, because the time to wake them up on a multi-tasking OS could easily be on the order of a few milliseconds.

7. Experiments Computation times were reported in Tables 2â4 and Figure 7. Performance under timestep and mesh reï¬nement are analysed in Figures 5 and 8, respectively. We also analysed stability under mesh and timestep reï¬nement, by applying an instantaneous force impulse to a vertex at the top of bridgeâs mast, in tetrahedral meshes L0, L1, L2 of Figure 5. We determined the largest stable timestep using bisection. Under implicit backward Euler, StVK and co-rotational linear FEM were both stable. Huge timesteps caused severe numerical viscosity, but simulations did not explode, for any mesh resolution. Under implicit Newmark with StVK, the largest stable timesteps at L1 and L2 meshes were 1.11Ã and 1.19Ã smaller than at L0, respectively. Co-rotational linear FEM stable timesteps were approximately 2Ã larger than StVK timesteps, at all mesh resolutions. In Figures 9 and 10, we analyse volume preservation and locking of tetrahedral and voxel meshes. Unless the material is very soft, the standard FEM methods preserve volume well (but not highly accurately), across a wide range of Poisson ratios Î½ (Figure 10). Even rarely used values such as Î½ = â0.5 or Î½ = 0 produce visually

c 2012 The Authors Computer Graphics Forum c 2012 The Eurographics Association and Blackwell Publishing Ltd.

F. S. Sin et al. / Vega: Non-Linear FEM Deformable Object Simulator

45

Figure 9: Locking under a static load. Data also correspond to Figure 10. (a) Rest pose, (b) tet mesh obtained by splitting voxels into tets, under Î½ = 0.45 (grey), 0.49 (blue), 0.499 (red); severe locking can be observed, (c) tet mesh (red) versus voxel mesh (blue), for Î½ = 0.49; the voxel mesh locks signiï¬cantly less than the tet mesh, (d and e) tet and voxel mesh, respectively, under progressive voxel subdivision, for Î½ = 0.49, L0 (red), L1 (blue), L2 (grey); under subdivision, locking in the tet mesh becomes less severe; a similar (but much smaller) effect can be observed in the voxel mesh. Same static load in (b)â(e).

Figure 10: Volume preservation: We measured the total mesh volume in the experiment depicted in Figure 9, as a function of Î½, for tets and cubes, and under mesh reï¬nement. Relative volume error is small (under 3.5%). We observed an interesting phenomenon: as Î½ is increased into the locking regime (Î½ > 0.45), a switch occurs from overestimating to underestimating the volume. Beyond Î½ > 0.499, all simulations are severely locked (see Figure 9b) and very visibly under-deform. Tetrahedral mesh locks so severely that simulations become unstable. The voxel mesh, however, starts preserving the volume more closely as Î½ â 0.5.

Figure 11: Multi-core scalability of linear system solver: Both Pardiso and PCG scale well with the number of cores. As material stiffness is increased, the direct solver (Pardiso) running times stay constant, whereas PCG times grow. L0 bridge tet mesh (4000 vertices, 12 827 tets). diso. This is expected since matrixâvector multiplications of iterative solvers parallelize better than back-substitutions in direct solvers. The tradeoff between direct and iterative solvers is determined by the material stiffness, or, equivalently, timestep size. Running time of direct solvers is largely independent of stiffness, whereas for iterative solvers, it increases with stiffness, as well as timestep size (Figure 11). This is because the mass matrix M is typically much better conditioned than the stiffness matrix K. For low stiffness values, or small timesteps, the M term dominates the system matrix (Equations 16 and 19), so PCG needs a small number of iterations for convergence. Under large stiffness or large timesteps, K is dominant, causing a higher system condition number and slower PCG convergence. In the extreme case, as timestep approaches inï¬nity, all dynamics is removed and the solver becomes equivalent to a static solver: numerically the most difï¬cult case. Assembling the global stiffness matrix: Vegaâs sparse matrix library uses the compressed sparse row format to store sparse

plausible results. The deformable methods presented in this work, however, struggle with near-incompressible Poisson ratios close to 0.5. Although they produce an output that preserves volume well, they âlockâ: system condition numbers grow, animations lose energy rapidly, may become unstable, and visibly deform to smaller deformations than under equal loads with smaller values of Î½ (Figure 9b). Locking becomes less severe with mesh reï¬nement (Figures 9d and e), and tetrahedral meshes lock signiï¬cantly more than voxel meshes (Figure 9c). In order to simultaneously avoid locking and achieve exact volume preservation, it is recommended to use FEM methods designed for this purpose, such as [ISF07]. We analysed linear system solver multi-core scalability in Figure 11. It can be seen that PCG parallelizes better than Par-

c 2012 The Authors Computer Graphics Forum c 2012 The Eurographics Association and Blackwell Publishing Ltd.

46

F. S. Sin et al. / Vega: Non-Linear FEM Deformable Object Simulator

matrices. In order to correctly write each elementâs stiffness matrix into the global stiffness matrix, a naive implementation would need to sort the indices of non-zero entries in each row, at runtime. Vega avoids this overhead by pre-sorting the indices at startup. For every element, it pre-computes V 2 integers, where V is the number of element vertices (V = 4 for tets and V = 8 for cubes), as follows. The 3V Ã 3V element stiffness matrix consists of dense 3 Ã 3 blocks, each of which corresponds to a pair of element vertices. Let us consider the n Ã n matrix obtained from the global 3n Ã 3n stiffness matrix, by shrinking each 3 Ã 3 block to a 1 Ã 1 matrix. Let vie be the global integer index of vertex i of element e, i = 1, . . . , V , in the shrunk n Ã n matrix. For each element e and each integer pair (i, j ), i, j = 1, . . . , V , we pre-compute an integer that gives the location in the compressed array of row vie of the 1 Ã 1 entry corresponding to the vertex pair e (vie , vj ) in e. Pre-computing the V 2 integers for each element is fast and only needs to be done once at startup. At runtime, one can then write the element stiffness matrix entries into the global matrix in O(1) time. Therefore, the global stiffness matrix assembly only requires a linear traversal of element stiffness matrix entries, with a negligible computational overhead. Note that direct solvers require all entries of the global stiffness matrix to be available for Cholesky factorization. For iterative solvers, in contrast to matrixfree approaches that need not form a global stiffness matrix and therefore reduce memory bandwidth [MZSâ 11], Vega computes the stiffness matrix once at each timestep, and re-uses it during the iterations. Mass lumping refers to forming a diagonal matrix by summing the entries in each row of the mass matrix. Such a simpliï¬ed matrix corresponds to pretending that the interiors of all mesh elements are massless, with all mass concentrated at the vertices. Therefore, the effect of mass lumping becomes less pronounced with mesh reï¬nement. All experiments in this paper were performed using the consistent (non-lumped) mass matrix. The sparse matrix library in Vega exploits the fact that the non-zero indices of the consistent M are a subset of non-zero indices of K, to efï¬ciently form the system matrix (Equations 16 and 19). If the mass matrix is lumped to a diagonal, this does not yield a substantial speedup for implicit integration. It does, however, accelerate explicit integration when âstiffnessâ damping is not used (Î² = 0), because the system matrix (Equation 20) becomes diagonal. 8. Discussion We presented a simulator that implements several common FEM deformable simulation methods in computer graphics, as well as a massâspring system, in a uniï¬ed framework. We provided practical experience and extensively compared the implemented strategies. Our code is simple and easily extensible, and the different components depend minimally on each other. The simulator exposes internal forces and tangent stiffness matrices using a well-documented interface, which should facilitate code reuse in applications in computer graphics, animation, robotics and virtual reality. Acceleration strategies: Our simulator can be readily extended to also include acceleration strategies such as model reduction [BJ05] and domain decomposition [HLBâ 06, BZ11]. In model reduction, one assumes that the deformations u lie in some (qual-

ity) low-dimensional space, u = U q, where U â R3nÃr is the time-invariant basis of the subspace, and r is the basis size. Equations of motion are then projected to this low-dimensional space, yielding equations of motion for q(t). A C/C++ implementation that timesteps q parallels the unreduced implementation, and can reuse several of its classes, such as the VolumetricMesh class. The key difference is that implicit solvers must solve dense linear systems of size r Ã r. The basis U can be obtained by applying Principal Component Analysis (PCA) to some pre-existing unreduced simulation data (computed, say, using the unreduced Vega simulator), or using modal derivatives [BJ05]. A pre-computation utility that performs the pre-process, as well as runtime code that shares some basic classes with Vega, are available at: http://www.jernejbarbic.com/code. For more details and a comparison to unreduced StVK, please refer to [BJ05]. For domain decomposition, the model reduction simulator can be extended, by using polar decomposition [MHTG05] to compute a frame for each domain. For details and experimental comparisons, please refer to [BZ11]. What approach is good for what application: We have found that co-rotational linear FEM and StVK behave very similarly under small / moderate deformations. With implicit integration, corotational linear FEM is faster (â¼ 20%) than invertible StVK. It is also more stable. For simulations that do not require the tangent stiffness matrix (explicit solvers), StVK is faster because one cannot easily separate stiffness matrix computation from internal force computation in the co-rotational linear FEM method. Under large compression, co-rotational linear FEM may permanently invert; therefore, for large compression, it is recommended to use QR decomposition as opposed to polar decomposition [PO09], or explicitly address invertibility [TSIF05]. Both co-rotational linear FEM and invertible StVK are good, general-purpose choices for computer graphics applications. The neo-Hookean material is typically used to simulate plastic and rubber-like materials in engineering. Massâspring systems are faster and easier to implement than the FEM methods, but are poor at preserving volume, and can easily tangle (invert) permanently. Hexahedral meshes lock less than tet meshes, and thus are preferred in applications where volume preservation is important. Standard StVK that computes forces as cubic polynomials is signiï¬cantly slower than invertible StVK that uses SVD. Therefore, it is recommended that practical StVK implementations use the invertible SVD algorithm. Such applications may even turn the invertibility threshold off, at which point invertible StVK exactly matches standard StVK, at a fraction of the computational cost. The cubic polynomial StVK algorithm, however, has the advantage that it commutes with a subspace projection operator, which is advantageous in model reduction applications. Cubic polynomials are also very easy to differentiate analytically, which is important in applications that need derivatives of the stiffness matrix, such as those involving optimization and control. Iterative solvers outperform direct solvers for large meshes where direct solvers struggle with ï¬tting the factorization in memory, and in applications where the material is soft or the timestep is small. Limitations and future work: Our simulator is currently limited to 3D solids, tetrahedral and cube meshes and isotropic materials. It does not incorporate collision detection. One can, however, use any

c 2012 The Authors Computer Graphics Forum c 2012 The Eurographics Association and Blackwell Publishing Ltd.

F. S. Sin et al. / Vega: Non-Linear FEM Deformable Object Simulator

47

collision library, compute penalty forces and apply them as external forces to our simulator. In the future, we plan to support anisotropic materials, higher-order mesh elements, and 3D shells (cloth) and rods. For example, we plan to include an implementation of the Baraff-Witkin cloth simulator [BW98]. We also plan to support deformable collision detection and contact resolution.

pling. In Proceedings of ACM SIGGRAPH 2001 (Los Angeles, CA, USA, 2001), pp. 31â36. [DW] DHONDT G., WITTIG K.: CALCULIX, A free software threedimensional structural ï¬nite element program. www.calculix.de [Erl] ERLEBEN K.: Hyper-sim. http://code.google.com/p/hyper-sim. [Han11] HANG SI: TetGen:A Quality Tetrahedral Mesh Generator and a 3D Delaunay Triangulator. [Hav] HAVOK: Havok.com Inc. www.havok.com. [HLB*06] HUANG J., LIU X., BAO H., GUO B., SHUM H.-Y.: An efï¬cient large deformation method using domain decomposition. Computers & Graphics 30, 6 (2006), 927â935. [ISF07] IRVING G., SCHROEDER C., FEDKIW R.: Volume conserving ï¬nite element simulations of deformable models. ACM Transactions on Graphics (SIGGRAPH 2007) 26, 3 (2007), 13:1â13:6. [ITF04] IRVING G., TERAN J., FEDKIW R.: Invertible ï¬nite elements for robust simulation of large deformation. In Symposium on Computer Animation (SCA) (Grenoble, France, 2004), pp. 131â140. Ë [JBT04] JAMES D. L., BARBIC J., TWIGG C. D.: Squashing cubes: Automating deformable model construction for graphics. In Proceedings of ACM SIGGRAPH Sketches and Applications (Los Angeles, CA, USA, 2004). [Kim] KIM T.: Cubica. http://www.mat.ucsb.edu/ kim/cubica/. [KMOD09] KHAREVYCH L., MULLEN P., OWHADI H., DESBRUN M.: Numerical coarsening of inhomogeneous elastic materials. ACM Transactions on Graphics 28, 3 (2009), 51:1â51:8. [KTY09] KIKUUWE R., TABUCHI H., YAMAMOTO M.: An edge-based computationally efï¬cient formulation of Saint Venant-Kirchhoff tetrahedral ï¬nite elements. ACM Transactions on Graphics 28, 1 (2009), 1â13. [LLJ*11] LEVIN D., LITVEN J., JONES G., SUEDA S., PAI D.: Eulerian solid simulation with contact. ACM Transactions on Graphics (SIGGRAPH 2011) 30, 4 (2011), 36:1â36:10.
U [MG04] MÂ¨ LLER M., GROSS M.: Interactive virtual materials. In Proceedings of Graphics Interface 2004 (London, ON, Canada, 2004), pp. 239â246. U [MHTG05] MÂ¨ LLER M., HEIDELBERGER B., TESCHNER M., GROSS M.: Meshless deformations based on shape matching. In Proceedings of ACM SIGGRAPH 2005 (Los Angeles, CA, USA, Aug 2005), pp. 471â478. U [MTG04] MÂ¨ LLER M., TESCHNER M., GROSS M.: Physically-based simulation of objects represented by surface meshes. In Proceedings of Computer Graphics International (CGI) (Crete, Greece, 2004), pp. 26â33.

Acknowledgements This research was sponsored in part by the National Science Foundation (CAREER-53-4509-6600) and by the James H. Zumberge Research and Innovation Fund at the University of Southern California. References [ABA] ABAQUS: ABAQUS Inc. www.hks.com. Ë [Bar07] BARBIC J.: Real-time Reduced Large-Deformation Models and Distributed Contact for Computer Graphics and Haptics. PhD thesis, Carnegie Mellon University, Aug. 2007. Ë [Bar12] BARBIC J.: Exact Corotational Linear FEM Stiffness Matrix. Tech. Rep., University of Southern California, 2012. Ë [BJ05] BARBIC J., JAMES D. L.: Real-time subspace integration for St. Venant-Kirchhoff deformable models. ACM Transactions on Graphics 24, 3 (2005), 982â990. [Bow09] BOWER A.: Applied Mechanics of Solids. CRC Press, Boca Raton, FL, USA, 2009. [BW98] BARAFF D., WITKIN A. P.: Large steps in cloth simulation. In Proceedings of ACM SIGGRAPH 98 (Orlando, FL, USA, 1998), pp. 43â54. [BW01] BARAFF D., WITKIN A.: Physically based modelling. In ACM SIGGRAPH Course Notes, ACM SIGGRAPH, Los Angeles, CA, USA 2001. [BW08] BONET J., WOOD R. D.: Nonlinear Continuum Mechanics for Finite Element Analysis, (2nd edition). Cambridge University Press, Cambridge, UK; New York, NY, USA, 2008. Ë [BZ11] BARBIC J., ZHAO Y.: Real-time large-deformation substructuring. ACM Transactions on Graphics (SIGGRAPH 2011) 30, 4 (2011), 91:1â91:7. Â´ [CGC*02] CAPELL S., GREEN S., CURLESS B., DUCHAMP T., POPOVIC Z.: Interactive skeleton-driven dynamic deformations. ACM Transactions on Graphics 21, 3 (2002), 586â593. [Cou] COUMANS E.: Bullet physics. www.bulletphysics.com. Â¨ [CPSS10] CHAO I., PINKALL U., SANAN P., SCHRODER P.: A Simple geometric model for elastic deformations. ACM Transactions on Graphics 29, 3 (2010), 38:1â38:6. [DDCB01] DEBUNNE G., DESBRUN M., CANI M.-P., BARR A. H.: Dynamic real-time deformations using space & time adaptive sam-

[MZS*11] MCADAMS A., ZHU Y., SELLE A., EMPEY M., TAMSTORF R., TERAN J., SIFAKIS E.: Efï¬cient elasticity for character

c 2012 The Authors Computer Graphics Forum c 2012 The Eurographics Association and Blackwell Publishing Ltd.

48

F. S. Sin et al. / Vega: Non-Linear FEM Deformable Object Simulator

skinning with contact and collisions. ACM Transactions on Graphics (SIGGRAPH 2011) 30, 4 (2011), 37:1â37:11. ËÂ´ Â´ [NKJF09] NESME M., KRY P. G., JERABKOVA L., FAURE F.: Preserving topology and elasticity for embedded deformable models. ACM Transactions on Graphics 28, 3 (2009), 52:1â52:9.
U [NMK*06] NEALEN A., MÂ¨ LLER M., KEISER R., BOXERMAN E., CARLSON M.: Physically based deformable models in computer graphics. Computer Graphics Forum 25, 4 (2006), 809â 836.

[PO09] PARKER E. G., OâBRIEN J. F.: Real-time deformation and fracture in a game environment. In Symp. on Computer Animation (SCA) (New Orleans, LA, USA, 2009), pp. 156â166. [SD06] STERN A., DESBRUN M.: Discrete geometric mechanics for variational time integrators. In ACM SIGGRAPH 2006 Courses (Boston, MA, USA, 2006), pp. 75â80. [Sha90] SHABANA A. A.: Theory of Vibration, Volume II: Discrete and Continuous Systems. SpringerâVerlag, New York, NY, USA, 1990. [She94] SHEWCHUK J. R.: An Introduction to the Conjugate Gradient Method Without the Agonizing Pain, Tech. Rep., Carnegie Mellon University, Pittsburgh, PA, USA, 1994. [SOF] SOFA: Simulation Open Framework Architecture: INRIA. www.sofa-framework.com. [SPO] SPOOLES: SParse Object Oriented Linear Equations Solver: Boeing Phantom Works. www.netlib.org/ linalg/spooles/spooles.2.2.html. [TSIF05] TERAN J., SIFAKIS E., IRVING G., FEDKIW R.: Robust quasistatic ï¬nite elements and ï¬esh simulation. In Symposium on Computer Animation (SCA) (Los Angeles, CA, USA, 2005), pp. 181â190. [Woo90] WOOD W. L.: Practical Time-Stepping Schemes. Clarendon Press, Oxford, UK, 1990. [Wri02] WRIGGERS P.: Computational Contact Mechanics. John Wiley & Sons, Ltd., Hoboken, NJ, USA, 2002.

[OH99] OâBRIEN J., HODGINS J.: Graphical modeling and animation of brittle fracture. In Proceedings of ACM SIGGRAPHâ 99 (Los Angeles, CA, USA, 1999), pp. 111â120. [Ope] OPENTISSUE:. Opensource Project, Generic algorithms and data structures for rapid development of interactive modeling and simulation. www.opentissue.org. [PAR] PARDISO: PARALLEL DIRECT SPARSE SOLVER INTERFACE: Pardiso project, www.pardiso-project.org and Intel MKL, software.intel.com/en-us/articles/intel-mkl. [PDA01] PICINBONO G., DELINGETTE H., AYACHE N.: Non-linear and anisotropic elastic soft tissue models for medical simulation. In IEEE International Conference on Robotics and Automation (Seoul, South Korea, 2001). [Phya] PHYSBAM: Stanford University. physbam.stanford.edu. [Phyb] PHYSX: Nvidia. www.nvidia.com/object/physx new.html.

c 2012 The Authors Computer Graphics Forum c 2012 The Eurographics Association and Blackwell Publishing Ltd.

