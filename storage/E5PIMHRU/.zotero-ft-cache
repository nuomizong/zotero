Tetrahedral and Hexahedral Invertible Finite Elements
G. Irving â , J. Teran, R. Fedkiw
Stanford University

Abstract We review an algorithm for the ï¬nite element simulation of elastoplastic solids which is capable of robustly and eï¬ciently handling arbitrarily large deformation. In fact, the model remains valid even when large parts of the mesh are inverted. The algorithm is straightforward to implement and can be used with any material constitutive model, and for both volumetric solids and thin shells such as cloth. We also discuss a mechanism for controlling plastic deformation, which allows a deformable object to be guided towards a desired ï¬nal shape without sacriï¬cing realistic behavior, and an improved method for rigid body collision handling in the context of mixed explicit/implicit time-stepping. Finally, we present a novel extension of our method to arbitrary element types including speciï¬c details for hexahedral elements. Key words: PACS:

1

Introduction

Signiï¬cant eï¬ort has been placed into making ï¬nite element simulation robust in the regime of large deformations, including the arbitrary LagrangianEulerian (ALE) formulations pioneered by [1], continuous remeshing (see e.g. [2,3] and the references therein), etc. However, as noted in [4], these approaches are often computationally intensive and diï¬cult to implement, which has primarily limited their use to two spatial dimensions. Moreover, [4] points out that these diï¬culties often lead authors to less optimal techniques such as
â Corresponding author. Email addresses: irving@cs.stanford.edu (G. Irving), jteran@stanford.edu (J. Teran), fedkiw@cs.stanford.edu (R. Fedkiw).

Preprint submitted to Elsevier Science

24 March 2005

Fig. 1. A highly curved region of an object is pushed inwards during a collision with a grey object (left), and a triangle used to represent this deformation is forced to invert (right).

element deletion. This not only degrades the accuracy of the simulation, but is unsuitable for graphics applications where disappearing tetrahedra cause visual artifacts. Since constitutive models for real materials are meaningful only for uninverted material, standard ï¬nite element simulation algorithms fail as soon as a single tetrahedron inverts. For this reason, various authors have proposed techniques for untangling inverted meshes. For example, [5] used feasible set methods and optimization to untangle two-dimensional meshes, [6] extended various tetrahedron quality metrics intended for mesh smoothing to the case of inverted tetrahedra allowing untangling to occur simultaneously with optimization, etc. However, none of these techniques are guaranteed to work, and fail quite often in practice especially if the boundary of the mesh is also tangled. And the failure to untangle a single tetrahedron forces the simulation to fail for most real world constitutive models. As pointed out by [3], element inversion can occur even if the vertex positions of the mesh are identical to their true continuum values. A common case of this is illustrated in Figure 1 where a triangle with three nodes on the boundary is forced to invert during a collision with another object. Even if an object as a whole deforms by only a small amount, say 10%, an individual element may undergo severe deformation due to errors in the discrete representation of the continuous material. In fact, large deformation and inversion can arise even when simulating incompressible material, since one typically cannot conserve volume for each individual element. Given that it is diï¬cult or impossible to prevent inversion in all cases, we propose a simpler approach that allows elements to invert gracefully and recover. 2

Fig. 2. A torus with zero strength collapses into a puddle. When the strength is increased, the torus recovers.

If the particular material behavior and underlying physics is unimportant, there are several techniques for treating inversion. For mass-spring systems, altitude springs work surprisingly well [7] (see also the work on âVan Helsingâ [8]). In fact, one can even add altitude springs to ï¬nite element models, but this changes the underlying partial diï¬erential equations and thus the behavior of the material (losing one of the key beneï¬ts of the ï¬nite element method as compared to mass-spring systems). Moreover, one cannot use constitutive models that lose meaning for inverting elements (which is most of them). Of course, one could switch from ï¬nite element methods to mass-spring methods for ï¬at, degenerate, and inverted elements but this leads to force discontinuities (detrimental to implicit time integration or quasistatic simulation), visual artifacts such as popping, etc. Various authors have proposed methods similar in spirit to altitude springs. [9] changes the underlying partial diï¬erential equation by adding a volume preservation term to penalize inversion. [10] ï¬rst computes and removes the rotation from material to spatial coordinates, and then applies a linear model in the unrotated space. Although the linear model works well for inverted elements, it is severely limited in the types of materials it can approximate. In fact, we stress that a spring is the most common linear model that correctly accounts for rotation. In [11], we took a diï¬erent approach motivated by the desire to continuously 3

(or smoothly) extend the ï¬nite element method so that it behaves gracefully for both degenerate and inverted elements, even for arbitrary constitutive models. This is especially important as a number of recent graphics publications have advocated the use of more advanced constitutive models to capture more realistic physical behavior. Moreover, many materials found in nature exhibit complex nonlinearities under large deformation, such as the biphasic nature of biological tissue and the anisotropic behavior of muscle. Our approach begins by computing a diagonalization of the deformation mapping in order to determine the âdirectionâ along which a given tetrahedron is inverted. The constitutive model is then extended into the inverted regime using C 0 , C 1 or higher continuity around the ï¬at state, resulting in smooth behavior even in extreme situations. The resulting forces always act to restore the tetrahedron to its original shape, allowing objects to recover cleanly from ï¬at or inverted conï¬gurations, as shown in Figure 2. The generality and robustness of the approach was illustrated with a number of simulations of objects undergoing large deformations, including nonlinear and anisotropic constitutive models, plasticity with and without control, both volumetric objects and thin shells, and fracture. This paper is an extended version of [11] including a review of the material presented therein. In addition, we also present an extension to arbitrary element types with speciï¬c details and simulation results for hexahedral elements. This is readily accomplished because the modiï¬cations required to handle inversion involve only the ï¬rst Piola-Kirchoï¬ stress P which is independent of the element type. Therefore, an arbitrary element can be made robust through inversion by modifying the computation of P at each quadrature point.

2

Related Work

[12â14] pioneered deformable models in computer graphics including early work on plasticity and fracture. Finite element simulations have been used to model a hand grasping a ball [15], to simulate muscles [16], for virtual surgery [17], and to simulate data from the NIH visible human data set [18,19]. [20] and [21] simulated brittle and ductile fracture respectively, while [22] coupled this work to explosions. Finite elements were also used for fracture in [23]. Other work includes the adaptive framework of [24], the rotation based approach in [25] and [10], the hybrid ï¬nite element free form deformation approaches in [26,27], and the ï¬nite volume muscle models of [28]. Other interesting approaches to the simulation of deformable objects include [29,30]. Many authors have worked to improve the robustness of mass-spring systems. [31] used a pseudopressure term in addition to edge springs, [32] used springs emanating from the barycenter of each tetrahedron to preserve volume, and 4

[33] introduced altitude springs to prevent triangles from collapsing. [7] later improved this model and applied it in three spatial dimensions to the case of tetrahedral mesh generation. If altitude springs are used correctly, not only is inversion not a problem, but the elements will work to un-invert. Unfortunately, spring systems do not allow the modeling of arbitrary constitutive models. We also show examples of our method at work for the in-plane deformations of lower dimensional manifolds such as cloth and shells. Here, since triangles cannot invert in three spatial dimensions, our method is similar to the work of [34], except that they do not consider degenerate elements. For out-of-plane forces, we use the bending model of [35] (see also [36]), and for self-collisions we use the method of [37]. Moreover, for volumetric collisions we also use the method in [37] simply applied to the triangulated boundary surface of the tetrahedron mesh. Other interesting work on cloth and shells includes the implicit time stepping of [38], the bending model of [39], the adaptive simulation work of [40], and the self-collision untangling strategy of [41].

3

Measuring deformation

A deformable object is characterized by a time dependent map Ï from material coordinates X to world coordinates x. The stress at a given point X in the material depends only on the deformation gradient F(X) = âx/âX of this mapping. Since we are using a purely Lagrangian framework, all mappings are based in material space. In order to discretely represent Ï, material space is divided into ï¬nite elements such as tetrahedrons or hexahedrons. In order to interpolate values deï¬ned on vertices in a consistent manner, we make use of isoparametric elements parameterized by Î¾ [42]. The point is that nodal values of a variable xi can be expressed throughout the element via
ne

x(Î¾) =
i=1

xi Ni (Î¾)

where ne is the number of vertices in the element and each Ni (Î¾) is an interpolating function associated with node i. Using this and the chain rule allows us to compute the deformation gradient as âx âx = F= âX âÎ¾ âX âÎ¾
â1

âNi (Î¾) = xi âÎ¾ i=1

ne

âNi (Î¾) Xi âÎ¾ i=1

ne

â1

.

For simplicity we assemble the spatial positions of the element vertices in a 3 Ã ne matrix Ds = [x1 , ..., xne ], and similarly for material positions, Dm = [X1 , ..., Xne ]. Additionally, we assemble the derivatives âNi in a ne Ã 3 matrix âÎ¾ 5

H = [ âN1 , Â· Â· Â· , âNne ]T . With these conventions, F can be written as F = âÎ¾ âÎ¾ Ds H(Î¾) (Dm H(Î¾))â1 . In order to estimate nodal forces for a given element, we must evaluate F at several quadrature points Î¾g . Since the element is ï¬xed in material coordinates, H(Î¾g ) (Dm H(Î¾g ))â1 is constant and can be precomputed for efï¬ciency. More importantly, as long as the initial mesh is reasonable, the ne Ã 3 matrix H(Î¾g ) (Dm H(Î¾g ))â1 is well-conditioned, and therefore Fg = Ds H(Î¾g ) (Dm H(Î¾g ))â1 is well-deï¬ned and ï¬nite regardless of the current state of the object. Furthermore, the values of Fg at the quadrature points contain all the information about the deformation of each element. In particular, we can monitor inversion at each quadrature point simply by checking the sign of det Fg . Once we have F, the next step is usually to deï¬ne the Green strain G = 1/2(FT F â I), and compute stress and forces based on G. We do not do this, however, since G is invariant with respect to all orthogonal transformations, including reï¬ection, and is therefore incapable of detecting inversion. Furthermore, G is already nonlinear in the deformation, and it is therefore more diï¬cult to interpret the large deformation behavior of a constitutive model based on G than one based on F, which is linearly related to deformation. Thus, for the remainder of this paper, we make the (nonrestrictive) assumption that the constitutive model is written explicitly in terms of F. In the case of tetrahedral elements, we use barycentric interpolation resulting in constant deformation gradients, and only one quadrature point is required. As a result the 4 Ã 4 matrix H has a particularly simple structure consisting of the identity matrix atop a row consisting of all â1 entries. Therefore, in [11], we absorbed H into Ds and Dm to obtain Ds = [x2 â x1 , x3 â x1 , x4 â x1 ], Dm = [X2 â X1 , X3 â X1 , X4 â X1 ] and F = Ds Dâ1 . Furthermore, if the material is m isotropic, we can save storage space by performing a QR-decomposition of Dm and storing only the upper triangular part, as noted in [23]. This corresponds to rotating material space, and therefore has no eï¬ect on an isotropic material. This optimization can be performed for an anisotropic model by rotating the anisotropic terms via the rotation from the QR-decomposition. Hexahedral elements are also commonly used and are determined by trilinearly interpolating nodal values throughout the primitive element [â1, 1]3 . The associated interpolating functions are given as (1 + (â1)i Î¾1 )(1 + (â1)j Î¾2 )(1 + (â1)k Î¾3 ) N4(iâ1)+2(jâ1)+k (Î¾) = 8 where i, j, k = 1, 2. Note that these elements do not yield a compact expression for the deformation gradient as in the case of tetrahedral elements. Additionally, the deformation gradient typically needs to be evaluated at 8 6

T

T

diï¬erent quadrature points within each element making hexahedral elements considerably more expensive than tetrahedral elements.

4

Force computation

When the constitutive model is given as a ï¬rst Piola-Kirchhoï¬ stress P, an elementâs contribution to the ï¬nite element force on one of its nodes xa is given as âNa T âNa T âX e dÎ¾ P dX = fa = P âX âX âÎ¾ â¦e â¦i m where â¦e represents the element in material space and â¦i represents the ideal m element. This integral can be approximated using quadrature as
ng e fa

=
g=1

Pg

âNa âX

T

g

âX âÎ¾

ng

Wg =
g g=1

Pg (Dm Hg )

âT

âNa âÎ¾

T

g

âX âÎ¾

Wg
g

where where ng is the number of quadrature points, Pg is the ï¬rst PiolaKirchhoï¬ stress at a quadrature point g, and Wg is the weight associated with quadrature point g. The second equality comes from âNa = âNa âX = âX âÎ¾ âÎ¾ â1 âNa (Dm H) . The elementâs contribution to all its nodal forces can be comâÎ¾ ng e e pactly represented as G = [f1 , Â· Â· Â· , fne ] = g=1 Gg where Gg = Pg (Dm Hg )âT HT g âX âÎ¾ Wg = Pg Bmg
g â1

using the deï¬nition of H. Note that since the 3 Ã ne matrix Bmg is constant, the nodal forces are linearly related to P. Therefore, the key to obtaining robust forces in the face of large deformation is an accurate calculation of P. If a constitutive model is given in terms of a Cauchy stress Ï or second PiolaKirchhoï¬ stress S, we can easily convert to a ï¬rst Piola-Kirchhoï¬ stress via the formulas P = FS and P = JÏFâT where J = det F. Alternatively, one could rewrite the force formula Gg = Pg Bmg directly in terms of the other stresses as Gg = Ïg Bsg or Gg = Fg Sg Bmg . Unlike the ï¬rst Piola-Kirchhoï¬ case where obtaining a valid Pg is suï¬cient to obtain robust forces, computing a valid Ïg or Sg is not enough. For example, if the element is a single point, Fg and thus Gg = Fg Sg Bmg are identically zero. In such instances there are no restorative forces. Therefore, we write all constitutive models in terms of P before force computation. In the case of tetrahedral elements, only one quadrature point is needed per element and an elementâs contribution to the elastic force on node i is equiva7

lent to gi = âP (A1 N1 + A2 N2 + A3 N3 ) /3, where Aj Nj are the area weighted normals (in material coordinates) of the faces of the tetrahedron incident to node i. This was shown in [28] and results from the fact that a ï¬rst PiolaKirchhoï¬ stress P is a mapping from area-weighted normals in material space to traction vectors in world space. See also [11] for more details. For hexahedral elements, 8 quadrature points per element are typically used. Particularly common is the second order quadrature that uses the points 1 1 1 Î¾4(iâ1)+2(jâ1)+k = (â1)i â , (â1)j â , (â1)k â 3 3 3 in the ideal domain with weights W4(iâ1)+2(jâ1)+k = 1 where i, j, k = 1, 2.

5

Diagonalization

Since rigid body rotations do not change the physics of a deformable object, the stress P satisï¬es P(UF) = UP(F) for any rotation U. (Here P(F) denotes function application.) Furthermore, if we temporarily assume an isotropic constitutive model, P is invariant under rotations of material space, i.e. P(FVT ) = P(F)VT . Therefore, if we diagonalize F via rotations U and V to obtain Ë F = UFVT , P becomes Ë Ë P = P(F) = UP(F)VT = UPVT (1)

where a hat superscript denotes the corresponding rotated quantity. Since the elastic energy of an isotropic material is invariant under world and material rotations, it can depend only on the invariants of F, or equivalently on the Ë entries of the diagonalization F (see e.g. [43]). Therefore, the gradient of the energy, Ï , will also be diagonal. Moreover, since the three stresses are related Ë ËË Ë ËË via Ï = (1/J)PFT and P = FS, the diagonalization of F actually results Ë Ë in the simultaneous diagonalization of all three stresses. In particular, P in equation 1 is diagonal for an isotropic constitutive model. For an anisotropic Ë Ë constitutive model, a diagonal F does not result in a diagonal P. However, this is not restrictive, and we show examples of anisotropic constitutive models in section 6.1. The diagonalization of F is not unique, however. While the ordering of the Ë entries of the diagonal matrix F is unimportant, the signs of the entries determine the particular direction of inversion. The standard SVD convention of choosing all nonnegative entries works only when det F â¥ 0. When det F < 0, the signs of the entries must be chosen carefully in order to guarantee that Ë the forces act to uninvert the element. In this case, F has either one or three negative entries. We heuristically assume that each element is as uninverted 8

Fig. 3. A hexahedron mesh collapses into a puddle and recovers.

as possible, and thus we assume that only one entry (not three) is negative. Moreover, the entry with the smallest magnitude is chosen to be negative. This is motivated by the geometric fact that an inverted tetrahedron can be uninverted by moving any one node across the plane of the opposite face, and it is most eï¬cient to choose the node that is closest to the opposite face. We compute the correct diagonalization by ï¬nding any diagonalization and correcting the signs. When doing this, we must be careful to ensure that the ï¬nal U and V are pure rotations, i.e., det U = det V = 1. This is because deformable objects are not invariant under reï¬ections of material or world space, and equation 1 does not hold if either U or V is a reï¬ection. We comË pute the SVD of F = UFVT as follows. First we form the normal equations T T T Ë Ë Ë F F = VFU UFV = VF2 VT . Then we rearrange to obtain an eigenprobT Ë 2 for the symmetric positive semideï¬nite FT F. Here, V is lem, F FV = VF Ë an orthogonal matrix of eigenvectors and F2 is a diagonal matrix with nonnegative entries. Robust computation of eigensystems for 3 Ã 3 matrices (even with repeated or zero eigenvalues) is a solved problem. And since it is relevant to rigid body simulations, it has received a lot of attention. Note that if V is a reï¬ection with det V = â1 we can simply multiply a column of V by â1 Ë to make V a rotation with det V = 1. The entries of F are then determined Ë by taking the square root of the diagonal elements of F2 , and U can be found Ë â1 for well shaped elements. However, if a diagonal entry of F Ë via U = FVF 9

is near zero, we do not use this formula for the corresponding column of U, but instead take it to be orthogonal to the other columns. For example, in the extreme case where F = 0, we choose U = I. Finally, to treat inversion where det F < 0, we have det U = â1 implying that U is a reï¬ection. This is Ë removed by negating the minimal element of F and the corresponding column of U. Figure 2 illustrates degeneracy and inversion handling for a tetrahedral torus mesh. Moreover, we have tested our approach for a variety of degenerate conï¬gurations, such as when a tetrahedron collapses to a single point or line, and the method always leads to robust recovery from inversion. Figure 3 shows similar results for a hexahedral mesh.

5.1

Other Rotations

Typically, authors use a polar decomposition to remove the world rotation of a tetrahedron producing a symmetric Fs with F = QFs . To recover from inversion, one must be careful to control the signs of the eigenvalues of Fs as in the diagonalization case. However, we know of no way to do this without Ë ï¬rst computing the full diagonalization F = UFVT , and forming the polar Ë decomposition via Q = UVT , Fs = VFVT . Polar decomposition was used by [34] for cloth simulation and [10] for volumetric solids, but neither showed how to correctly handle inverting or degenerate elements. However, for the cloth case, we note that triangles do not invert in three spatial dimensions (although they can become degenerate). Both tetrahedra in three spatial dimensions and triangles in two spatial dimensions can invert and become degenerate. Alternatively, one could attempt to remove the world rotation with a QRdecomposition, i.e. F = QFr with Fr an upper triangular matrix. However, any stress which depends linearly on Fr will be anisotropic in a mesh dependent way, since it is not invariant under rotations of material space. To see this, it suï¬ces to note that if V is a rotation of material space, then FVT = QFr VT , and Fr VT is not upper triangular. Therefore, QRdecomposition is inadvisable even if physical accuracy is not a requirement. Moreover, this is a problem with any method for removing rotations, such as [25], that does not use Q = UVT for the world rotation. Note that our approach departs from the typical goal of determining (or approximating) the rotation from material space to world space, i.e. Q from the polar decomposition. Instead, we look for two rotations U and V such that UT and VT rotate the world and material spaces, respectively, to a space where the deformation gradient is a diagonal matrix. This is preferable to the space obtained using Q in which the deformation gradient is a more complex symmetric matrix. 10

6

Constitutive Models

Once we have carefully diagonalized F, we can extend our constitutive models to behave reasonably under inversion. The diagonal setting makes this quite simple. If St. Venant-Kirchhoï¬ material is compressed beyond a certain point, it gets weaker and weaker as the compression increases, and the stress drops to zero as the object becomes ï¬at. Moreover, if an element inverts, the forces act to keep the element inverted. See Figure 4 (upper left). As noted in [43], this makes the St. Venant-Kirchhoï¬ model completely useless for modeling large deformations. [20] noted these diï¬culties, but dismissed them since they were simulating rigid materials. However, as discussed previously, stiï¬ or incompressible objects may still have inverted elements due to discretization error, especially on the coarse grids common in the computer graphics community. In order to alleviate the problems with the St. Venant-Kirchhoï¬ model, various authors (e.g. [17]) have proposed adding a pseudo-pressure term to prevent element inversion. In fact, the classical neo-Hookean constitutive model already does this as shown in Figure 4 (upper right). The singularity at the origin means that inï¬nite energy is required to completely ï¬atten an element, and as long as the equations for this constitutive model are accurately simulated, inversion is prevented. However, preventing inversion also prevents the handling of situations where inversion is the desired, correct response, as in Figure 1. Moreover, since the forces become arbitrarily large, the system can become arbitrarily stiï¬ and diï¬cult to integrate, making it diï¬cult to handle situations such as that shown in Figure 7 where a volumetric Buddha model is pulled through rigid, interlocking gears. To avoid the unnecessary stiï¬ness associated with the neo-Hookean constitutive model, we modify the constitutive model near the origin to remove the singularity by either linearizing at a given compression limit or simply clamping the stress at some maximum value. Moreover, as shown in Figure 4 (lower right), we extend the model past the origin into the inverted regime in order to obtain valid forces for inverted elements. These forces act to uninvert the element. Note that since we have removed both spatial and material rotations by diagonalizing, the modiï¬ed model is automatically rotation invariant and isotropic. The major strength of the diagonal setting is that these modiï¬cations can be applied to arbitrary constitutive models. This is quite natural, since the diagonal setting is also commonly used in the experimental determination of material parameters. The resulting model is identical to the physical model most of the time, and allows the simulation to continue if a few elements 11

Ë Fig. 4. The relationship between the ï¬rst Piola-Kirchhoï¬ stress P and the deformaË for various constitutive models. tion gradient F

invert. Furthermore, our extensions provide C 0 or C 1 continuity around the ï¬at case, which avoids sudden jumps or oscillations which might eï¬ect neighboring elements. While it may seem nonphysical to modify a constitutive model for inversion handling, most constitutive models lose accuracy long before inversion occurs. It is exceedingly diï¬cult to measure material response in situations of extreme compression, so constitutive models are often measured for moderate deformation and continued heuristically down to the ï¬at cases. Given that some accuracy loss is unavoidable when elements are extremely degenerate, it is preferable to provide smooth, consistent handling of inversion in order to avoid unnecessary corruption of the more meaningful parts of the simulation. 12

Fig. 5. A simulation of muscles driven by a key-framed skeleton. The muscle is represented with a transversely isotropic constitutive model, and the strength along the ï¬ber direction in the muscle is based on activation levels.

If a speciï¬c qualitative material behavior is desired but the exact quantitative model is less important, we can use the diagonal setting to construct a suitable constitutive model. For example, most biological material is soft under small deformation, but becomes stiï¬er as the deformation increases. A simple model capturing this behavior is given by choosing threshold values for compression and elongation, specifying the slope of the stress curve outside these threshold values and at the undeformed state, and using a cubic spline to interpolate between them. This model, equipped with a linear pressure component, was used for the simulations of the volumetric Buddha model shown in Figures 6 and 7, and the hexahedral simulation in Figure 8. Note that any isotropic constitutive model expressed in diagonal form will automatically preserve anË Ë Ë Ë gular momentum, since if P is diagonal, S = Fâ1 P is symmetric (see e.g. [43]). For the torus puddle, hexahedron puddle, and plastic sphere simulations (see Figures 2 and 9), where the focus is on degeneracy and plasticity, respectively, Ë Ë Ë we used the simple rotated linear model P = 2Âµ(F â I) + Î»tr(F â I) depicted in Figure 4 (lower left). Ë Once we have computed the diagonalized stress P at a given quadrature point, the force computation becomes Ë ËË G = UPVT Bm = UPBm 13 (2)

Ë where Bm = VT Bm can be computed and stored if the rotation is ï¬xed for multiple force computations, as in some versions of Newmark time integration (see section 9). 6.1 Anisotropy

If the constitutive model includes anisotropic components, it is no longer invariant under rotations of material space. However, we can continue to fully diagonalize F, and rotate the anisotropic terms using V. Since we still work Ë with a diagonal F, the large deformation behavior of the constitutive model is still apparent and easy to modify to handle inversion. For example, if the material is stronger in a certain material direction a, we diagonalize F and use Ë Ë VT a in the computation of P. P is no longer a diagonal matrix, but we can still compute forces using equation 2. When constructing anisotropic constituË Ë tive models that allow inversion, we write P as a diagonal matrix plus F times â1 Ë Ë Ë a symmetric matrix for the anisotropic terms. Then S = F P is symmetric (preserving angular momentum) as required. We illustrate the handling of anisotropy with an example simulation of skeletal muscle in the upper limb (see Figure 5). We use a nonlinear transverselyisotropic quasi-incompressible constitutive model. See [44] for more details. This is an intricate region of the body articulated with complex joints in the shoulder, elbow and wrist. Inaccuracy in the joint models and motion data leads to skeletal conï¬gurations that are incompatible with the musculature creating boundary conditions that degenerately deform muscles and tendons leading to spurious element inversion. However, these conï¬gurations often only occur in limited regions of the mesh and only for brief moments during a given motion. Our algorithm allows simulations to progress past these temporary problems by letting elements invert and then later recover. 6.2 Damping

Ë Damping forces can be implemented by rotating the velocity gradient F by Ë the same U and V used to diagonalize F, computing the damping stress P in the rotated frame, and computing the force exactly as for the elastic case. Note that the rotated velocity gradient will in general not be diagonal. As in the case of anisotropic elastic forces, a damping model will only preserve Ë ËË Ë angular momentum if P can be expressed as FS, with S symmetric. This was not a problem for anisotropy since the anisotropic terms are usually not important for ï¬at or inverted elements. However, in order to prevent visually unpleasant oscillations, we do not want the damping forces to disappear for 14

ï¬at elements. For example, the analogous damping model to the rotated linear Ë Ë Ë Ë Ë Ë Ë constitutive model, P = Î²(F + FT ) + Î±tr(F), does not preserve angular moË is a uniform scaling. However, since the angular momentum mentum unless F errors are small around the undeformed state, and highly deformed elements are usually interacting with other objects, we have not found this lack of conservation to be visually noticeable. In simulations where more physical accuracy is desired, we use a correct damping model for moderate deformations and a more robust but nonphysical model for the few ï¬at or inverted elements.

6.3

Plasticity

We represent plastic deformation with a multiplicative decomposition of the deformation F = Fe Fp , where Fp represents the permanent plastic deformation and Fe the elastic deformation, see e.g. [43] or [45]. The multiplicative formulation allows a complete separation between plastic ï¬ow and elastic forces, and makes constraints such as volume preservation simple to enforce. In contrast, the additive plasticity formulation of [21] does not support true incompressibility, though this might not be a signiï¬cant problem for graphics applications. Note that if the elastic constitutive model is isotropic, the rotational part of Fp is arbitrary, e.g. we can choose Fp to be symmetric. We restrict ourselves to rate-independent plasticity models, and use the return mapping algorithm to transfer deformation from the elastic part Fe to the plastic part Fp whenever a yield criterion on Fe is exceeded. The details of the computation of plastic ï¬ow are as follows. Compute the trial elastic deforË mation Fe,trial = FFâ1 , and ï¬nd the diagonalization Fe,trial = UFe,trial VT . If p Ë a yield criterion on Fe,trial is exceeded, project back onto the yield surface proË ducing a new diagonal matrix Fe,proj . Compute the trial plastic deformation Ë e,proj Fp,trial = Fâ1 UT F (dropping V since rotations of Fp are unimportant). If Fp,trial exceeds a separate limit criterion, project it back onto the limit surface producing the ï¬nal Fp . Compute and store Fâ1 for future use. p This structure supports an arbitrary plastic yield criterion while still ensuring that the plastic deformation does not become too extreme. This is important, since the time step required for stability depends on the conditioning of Fp . In particular, Fp should never invert. This can be implemented in the diagonal Ë Ë framework by ensuring that the projection of Fe always results in an Fe,proj with positive entries. The ï¬nal limiting of Fp,trial can then be adjusted to ensure a well-conditioned Fp . Figure 11 shows a simulation of ductile fracture using this technique. See [46] for more details. 15

7

Controlling Plasticity

Various authors, such as [47â49], have considered controlling physics based simulations. The ability to control a simulation alleviates the need for laborious parameter tuning to achieve a desired eï¬ect, and makes possible animations which could not be achieved through physical accuracy alone. In the context of plasticity, we can use the plastic limiting projection step to control the plastic deformation toward any desired state without sacriï¬cing realism. To do this, we compute a goal deformation Fp,goal at the beginning of the simulation. In the plastic projection step, we are given a tentative plastic ï¬ow from the old deformation Fp to the trial deformation Fp,trial . In order to always move towards Fp,goal , we choose the ï¬nal plastic deformation to be the point on the segment from Fp to Fp,trial which is closest to Fp,goal . This computation is actually performed on the logarithms of each Fp after removing the world rotation. Since the mapping from rest to goal state will rarely preserve volume locally, volume preservation should not be used during the elastic projection step. Allowing some ï¬exibility in the plastic ï¬ow allows the deformation to pick up additional ï¬ne detail not present in the goal state. For example, Figure 9 shows a plastic sphere pulled through interlocking gears. The sphere is controlled towards the ï¬attened disk shape. In particular, the goal state does not include the teeth marks present in the ï¬nal state of the sphere. A more obvious example of control is shown in Figure 9. Both of these examples used the simple yield criterion log Fe â¤ Î³.

8

Thin Shells and Cloth

The diagonalized framework is readily extended to handle the in-plane behavior of triangles for modeling thin shells and cloth (see Figure 6). Here, F is Ë a 3 Ã 2 matrix decomposed as F = UFVT where U is a 3 Ã 2 matrix with Ë orthonormal columns, F is a 2 Ã 2 diagonal matrix, and V is a 2 Ã 2 rotation matrix. Everything else follows in a straightforward manner. Inversion does not occur for freely moving thin shells and cloth, since an âinvertedâ triangle is indistinguishable from a triangle that has been rotated 180â¦ out of plane. However, when triangles degenerate to lines or points special care is needed. Moreover, when a shell approximates a two dimensional surface such as during surface mesh generation (see e.g. [7]), âinversionâ can occur. That is, a triangle can be tested for inversion by considering the sign of the dot product between its face normal and a known approximation to the surface normal at the center of the triangle. If this sign is negative, the triangle can 16

Ë be considered inverted, and the signs of the entries of F can be corrected as before. Thus, the triangle acts to uninvert by ï¬ipping the direction of its face normal. For bending forces, we use the formulation of [35], which is similar to that of [36]. The bending model is independent of the in-plane model, and in-plane plasticity is analogous to the three dimensional case. To allow plastic bending, we apply the plastic ï¬ow algorithm to the rest angles between each pair of adjacent triangles. An example of a shell simulation showing both in-plane and bending plasticity is shown in Figure 10.

9

Time-Stepping and Collision Handling

We use the Newmark time-stepping scheme of [35] with explicit integration for the elastic forces and implicit integration for the damping forces. Treating only the damping forces implicitly removes the strict quadratic time step restriction required by fully explicit schemes without introducing the extra artiï¬cial damping characteristic of fully implicit schemes. As most damping models are linear in the velocities with a positive deï¬nite, symmetric Jacobian, the implicit integration can be implemented using a fast conjugate gradient solver. We modify [35]âs scheme slightly to improve the handling of rigid body collisions. Speciï¬cally, we use the velocity from the last implicit update as input to the rigid body collision algorithm, and use constraints in the velocity update to prevent motion in the direction normal to the rigid body for points experiencing a collision. The resulting algorithm to move from step n to n + 1 is as follows: Ë â¢ v n+1/2 = v n + ât a(tn , xn , v n+1/2 ) Ë 2 n+1 n n+1/2 â¢ x Ë = x + âtË v â¢ Process rigid body collisions using xn+1 and v n , producing ï¬nal positions Ë n+1 n x and modiï¬ed velocities v . Ë n+1 n n n n â¢ v = v + ât (a(t , x , v ) + a(tn+1 , xn+1 , v n+1 )) /2 Ë Ë Note that the last line is exactly the trapezoidal rule applied to the velocities. This algorithm supports a variable time step with second order accuracy and monotone behavior. Since the positions change only in lines 2 and 3 of the algorithm, we can compute F and its diagonalization only once per time step after step 3. Plastic ï¬ow is also computed at this time. With this optimization, the cost of diagonalization becomes negligible compared to the cost of the implicit velocity updates. 17

The rigid body collision processing is based on the algorithm of [35]. We represent rigid bodies as implicit surfaces, which simpliï¬es collision detection. Each such node is projected to the surface of the object, and its normal velocity is set to that of the object if it is not already moving away from it. We incorporate friction by changing the relative tangential velocity vT,rel to
new vT,rel = max 0, 1 â Âµ

âvN + âxN /ât vT,rel |vT,rel |

where âxN and âvN are the changes in position and normal velocity from the projection step. The âxN /ât term ensures that the particle will experience the correct friction for the change in position imparted by the object. This term was not considered in [35]. Any node involved in a collision is ï¬agged, and its normal velocity is held ï¬xed during the ï¬nal trapezoidal rule step. Enforcing normal velocities of colliding particles via constraints during the velocity update further increases the stability of the collision scheme, since it allows a nonlocal response to collision. This strategy is similar to that proposed in [38], who implemented rigid body collisions in their fully implicit scheme via constraints in the conjugate gradient solver. Since projecting points to the surface of an object tends to crush elements, the ability to handle ï¬at or inverted elements is essential to enable the use of reasonable time steps. Also, since the rigid body collision algorithm is applied to surface vertices only, not surface triangles, it is useful to apply the algorithm to the interior points as well as the surface points, to prevent small rigid bodies from slipping between surface points into the interior of the object. The importance of this increases for very soft objects, as very soft surface triangles can easily expand and pass around even moderately sized obstacles. For self-collisions we extract the boundary surface and apply the cloth collision algorithm of [37]. This algorithm is applied âoutsideâ of the time-stepping algorithm outlined above. Although a surface-only collision algorithm does not prevent the interior of the object from extending outside its boundary, our method has no diï¬culty with this inversion and only the surface is needed for rendering.

10

Examples

We used the algorithm of [7] to generate the tetrahedral meshes used in this paper. Even without preconditioning in the CG solver, computation times were generally under 20 minutes per frame for the largest meshes. Of course, coarser 18

meshes can be simulated in just a few minutes a frame. For example, the torus simulation in Figure 2 ran at around 10 to 20 seconds per frame with the 115K element mesh, and .5 to 1 second per frame with an 11K element mesh. All the simulations involved large numbers of inverted elements: a typical frame from the Buddha simulation in Figure 7 had about 29K inverted tetrahedrons out of a total of 357K tetrahedrons, or about 8% of the mesh. The Buddha with cape example in Figure 6 was simulated in two layers, with one-way coupling from the Buddha to the cloth using the collision processing algorithm from section 9. We used the exact triangulated surface geometry of the Buddha in order for the cloth to resolve the many features of the Buddha mesh. To evaluate the Buddha as an implicit surface at a cloth vertex v, we ï¬nd the closest point p to v on the Buddha surface (which may lie on a vertex, edge, or face) and deï¬ne the ânormalâ at v to be in the direction from v to p or p to v, whichever points outwards. The hexahedral meshes shown in Figures 3 and 8 were cut out of regular cubic grids in the obvious way. For self-collision handling and rendering, we divide each boundary quadrilateral into two triangles. This adds no new degrees of freedom, and does not eï¬ect the hexahedral force computation.

11

Comparison of Tetrahedral and Hexahedral Elements

Given the ability to robustly handle inverted elements, it becomes possible to use all vertex degrees of freedom in order to represent deformation without danger of breaking the simulation. Therefore, we can compare the eï¬ciency of tetrahedral and hexahedral elements simply by comparing the eï¬ort required to evaluate the force on each vertex. This can be further broken down into the number of quadrature points per vertex and the cost of each quadrature point. A standard cubic grid of hexahedrons has approximately one element per vertex, and 8 quadrature points per element, or about 8 quadrature points per vertex. Dividing each hexahedron into 5 tetrahedra with a Freudenthal cut produces 5 quadrature points per vertex. The regular BCC tetrahedral lattice used in [7] has 4 tetrahedra for each face in a cubic grid and doubles the number of vertices by adding the center of each cube, resulting in 6 quadrature points per vertex. In both of these examples, the number of quadrature points per vertex is larger for hexahedral meshes than for tetrahedral meshes. Since the work required per quadrature point is also larger for hexahedra due to the use of 8 Ã 3 matrices, tetrahedral elements are signiï¬cantly faster per vertex than hexahedral elements. 19

12

Discussion

We stress here that element inversion does not imply that mass or even volume is necessarily lost. In fact, there are precedents for our approach in the ï¬nite element literature. When considering incompressible or nearly incompressible materials, linear tetrahedral elements suï¬er from severe volumetric and strain locking precluding their use. The problem occurs because tetrahedra have limited ï¬exibility under the constraint that their volume has to be preserved (or almost preserved), especially when they are connected into a mesh of elements that all have this same volume preservation constraint. [50] partially alleviate this problem by allowing material to ï¬ow between elements so that the overall volume can be preserved without preserving the volume of each individual element. Another very interesting approach is the F-bar approach of [51] (see also Â¯ [52]). The F-bar approach deï¬nes a modiï¬ed deformation gradient F, which replaces the volume change in each element with the average volume change over a patch of several elements. This is similar in spirit to composite element approaches, see e.g. [53,54]. The F-bar approach allows individual elements to change volume as much as they want as long as the volume of the patch is preserved, signiï¬cantly alleviating diï¬culties with locking. Element inversion can be viewed in the context of incompressibility and locking. Restricting individual linear tetrahedra to a non-inverted state is too restrictive for some deformations, and it would be better to consider a patch of elements as in the F-bar technique. That is, one could imagine a method that allows an individual tetrahedron to invert as long as a larger patch of tetrahedra that contain the inverted element does not invert. Then mass (or volume) is not lost, but just transferred to other tetrahedra in the patch.

13

Conclusions

We have presented a new method for modifying an elastic constitutive model to behave robustly for inverted elements, which works by carefully diagonalizing the deformation mapping prior to computing forces. Examples were presented to demonstrate that this algorithm works well for volumetric and thin shell simulations involving degeneracy, complex geometries, anisotropic constitutive models, plasticity with and without control, ductile fracture, and coupling between diï¬erent types of deformable objects. Although we originally presented this method for tetrahedra (only) in [11], here we generalized its application to quadrature points in arbitrary elements presenting speciï¬c details and simulations for the case of hexahedra. 20

14

Acknowledgement

Research supported in part by an ONR YIP award and a PECASE award (ONR N00014-01-1-0620), a Packard Foundation Fellowship, a Sloan Research Fellowship, ONR N00014-03-1-0071, ARO DAAD19-03-1-0331, NSF IIS-0326388, NSF ACI-0323866, NSF ITR-0205671 and NIH U54-GM072970. In addition, G. I. and J. T. were supported in part by NSF Graduate Research Fellowships. We would also like to thank Mike Houston for providing computing resources used for rendering.

References

[1] C. Hirt, A. Amsden, J. Cook, An arbitrary Lagrangian-Eulerian computing method for all ï¬ow speeds, J. Comput. Phys. 135 (1974) 227â253. [2] G. Camacho, M. Ortiz, Adaptive Lagrangian modelling of ballistic penetration of metallic targets, Comput. Meth. in Appl. Mech. and Eng. 142 (1997) 269â301. [3] H. Espinosa, P. Zavattieri, G. Emore, Adaptive FEM computation of geometric and material nonlinearities with application to brittle failure, Mech. Materials 29 (1998) 275â305. [4] G. Bessette, E. Becker, L. Taylor, D. Littleï¬eld, Modeling of impact problems using an h-adaptive, explicit lagrangian ï¬nite element method in three dimensions, Comput. Meth. in Appl. Mech. and Eng. 192 (2003) 1649â1679. [5] P. Vachal, R. Garimella, M. Shashkov, Untangling of 2D meshes in ALE simulation, J. Comput. Phys. 196 (2004) 627â644. [6] J. Escobar, E. RodrÂ´ Ä±guez, R. Montenegro, G. Montero, J. GonzÂ´lez-Yuste, a Simultanous untangling and smoothing of tetrahedral meshes, Comput. Meth. in Appl. Mech. and Eng. 192 (2003) 2775â2787. [7] N. Molino, R. Bridson, J. Teran, R. Fedkiw, A crystalline, red green strategy for meshing highly deformable objects with tetrahedra, in: 12th Int. Meshing Roundtable, 2003, pp. 103â114. [8] R. Kautzman, A. Maiolo, D. Griï¬n, A. Bueker, Jiggly bits and motion retargetting: Bringing the motion of hyde to life in van helsing with dynamics, in: SIGGRAPH 2004 Sketches & Applications, ACM Press, 2004. [9] M. Teschner, B. Heidelberger, M. Muller, M. Gross, A versatile and robust model for geometrically complex deformable solids, in: Proc. Computer Graphics International, 2004. [10] M. Muller, M. Gross, Interactive virtual materials, in: Graph. Interface, 2004.

21

[11] G. Irving, J. Teran, R. Fedkiw, Invertible ï¬nite elements for robust simulation of large deformation, in: Proc. of the ACM SIGGRAPH/Eurographics Symp. on Comput. Anim., 2004, pp. 131â140. [12] D. Terzopoulos, J. Platt, A. Barr, K. Fleischer, Elastically deformable models, Comput. Graph. (Proc. SIGGRAPH 87) 21 (4) (1987) 205â214. [13] D. Terzopoulos, K. Fleischer, Modeling inelastic deformation: viscoelasticity, plasticity, fracture, Comput. Graph. (SIGGRAPH Proc.) (1988) 269â278. [14] D. Terzopoulos, K. Fleischer, Deformable models, The Visual Computer (4) (1988) 306â331. [15] J.-P. Gourret, N. Magnenat-Thalmann, D. Thalmann, Simulation of object and human skin deformations in a grasping task, Comput. Graph. (SIGGRAPH Proc.) (1989) 21â30. [16] D. Chen, D. Zeltzer, Pump it up: Computer animation of a biomechanically based model of muscle using the ï¬nite element method, Comput. Graph. (SIGGRAPH Proc.) (1992) 89â98. [17] G. Picinbono, H. Delingette, N. Ayache, Non-linear and anisotropic elastic soft tissue models for medical simulation, in: IEEE Int. Conf. Robot. and Automation, 2001. [18] Q. Zhu, Y. Chen, A. Kaufman, Real-time biomechanically-based muscle volume deformation using FEM, Comput. Graph. Forum 190 (3) (1998) 275â284. [19] G. Hirota, S. Fisher, A. State, C. Lee, H. Fuchs, An implicit ï¬nite element method for elastic solids in contact, in: Proc. of Computer Animation, 2001, pp. 136â146. [20] J. OâBrien, J. Hodgins, Graphical modeling and animation of brittle fracture, in: Proc. SIGGRAPH 99, Vol. 18, 1999, pp. 137â146. [21] J. OâBrien, A. Bargteil, J. Hodgins, Graphical modeling of ductile fracture, ACM Trans. Graph. (SIGGRAPH Proc.) 21 (2002) 291â294. [22] G. Yngve, J. OâBrien, J. Hodgins, Animating explosions, in: Proc. SIGGRAPH 2000, Vol. 19, 2000, pp. 29â36. [23] M. Muller, L. McMillan, J. Dorsey, R. Jagnow, Real-time simulation of deformation and fracture of stiï¬ materials, in: Comput. Anim. and Sim. â01, Proc. Eurographics Workshop, Eurographics Assoc., 2001, pp. 99â111. [24] G. Debunne, M. Desbrun, M. Cani, A. Barr, Dynamic real-time deformations using space & time adaptive sampling, in: Proc. SIGGRAPH 2001, Vol. 20, 2001, pp. 31â36. [25] M. Muller, J. Dorsey, L. McMillan, R. Jagnow, B. Cutler, Stable real-time deformations, in: ACM SIGGRAPH Symp. on Comput. Anim., 2002, pp. 49â 54.

22

[26] S. Capell, S. Green, B. Curless, T. Duchamp, Z. PopoviÂ´, Interactive skeletonc driven dynamic deformations, ACM Trans. Graph. (SIGGRAPH Proc.) 21 (2002) 586â593. [27] S. Capell, S. Green, B. Curless, T. Duchamp, Z. PopoviÂ´, A multiresolution c framework for dynamic deformations, in: ACM SIGGRAPH Symp. on Comput. Anim., ACM Press, 2002, pp. 41â48. [28] J. Teran, S. Blemker, V. Ng, R. Fedkiw, Finite volume methods for the simulation of skeletal muscle, in: Proc. of the 2003 ACM SIGGRAPH/Eurographics Symp. on Comput. Anim., 2003, pp. 68â74. [29] D. James, D. Pai, DyRT: Dynamic response textures for real time deformation simulation with graphics hardware, ACM Trans. Graph. (SIGGRAPH Proc.) 21 (2002) 582â585. [30] D. James, K. Fatahalian, Precomputing interactive dynamic deformable scenes, ACM Trans. Graph. (SIGGRAPH Proc.) 22 (2003) 879â887. [31] B. Palmerio, An attraction-repulsion mesh adaption model for ï¬ow solution on unstructured grids, Comput. and Fluids 23 (3) (1994) 487â506. [32] D. Bourguignon, M. P. Cani, Controlling anisotropy in mass-spring systems, in: Eurographics, Eurographics Assoc., 2000, pp. 113â123. [33] L. Cooper, S. Maddock, Preventing collapse within mass-spring-damper models of deformable objects, in: The 5th Int. Conf. in Central Europe on Comput. Graphics and Vis., 1997. [34] O. Etzmuss, M. Keckeisen, W. Strasser, A fast ï¬nite element solution for cloth modelling, in: Paciï¬c Graph., 2003, pp. 244â251. [35] R. Bridson, S. Marino, R. Fedkiw, Simulation of clothing with folds and wrinkles, in: Proc. of the 2003 ACM SIGGRAPH/Eurographics Symp. on Comput. Anim., 2003, pp. 28â36. [36] E. Grinspun, A. Hirani, M. Desbrun, P. Schroder, Discrete shells, in: Proc. of the 2003 ACM SIGGRAPH/Eurographics Symp. on Comput. Anim., 2003, pp. 62â67. [37] R. Bridson, R. Fedkiw, J. Anderson, Robust treatment of collisions, contact and friction for cloth animation, ACM Trans. Graph. (SIGGRAPH Proc.) 21 (2002) 594â603. [38] D. Baraï¬, A. Witkin, Large steps in cloth simulation, in: Proc. SIGGRAPH 98, 1998, pp. 1â12. [39] K.-J. Choi, H.-S. Ko, Stable but responsive cloth, ACM Trans. Graph. (SIGGRAPH Proc.) 21 (2002) 604â611. [40] E. Grinspun, P. Krysl, P. Schroder, CHARMS: A simple framework for adaptive simulation, ACM Trans. Graph. (SIGGRAPH Proc.) 21 (2002) 281â290.

23

[41] D. Baraï¬, A. Witkin, M. Kass, Untangling cloth, ACM Trans. Graph. (SIGGRAPH Proc.) 22 (2003) 862â870. [42] T. Hughes, The Finite Element Method: Linear Static and Dynamic Finite Element Analysis, Prentice Hall, 1987. [43] J. Bonet, R. Wood, Nonlinear continuum mechanics for ï¬nite element analysis, Cambridge University Press, Cambridge, 1997. [44] J. Teran, E. Sifakis, S. Salinas-Blemker, V. Ng-Thow-Hing, C. Lau, R. Fedkiw, Creating and simulating skeletal muscle from the visible human data set, IEEE Trans. on Vis. and Comput. Graph. 11 (3) (2005) 317â328. [45] F. Armero, E. Love, An arbitrary lagrangian-eulerian ï¬nite element method for ï¬nite strain plasticity, Int. J. Num. Meth. Eng. 57 (2003) 471â508. [46] N. Molino, J. Bao, R. Fedkiw, A virtual node algorithm for changing mesh topology during simulation, ACM Trans. Graph. (SIGGRAPH Proc.) 23 (2004) 385â392. [47] N. Foster, D. Metaxas, Controlling ï¬uid animation, in: Computer Graphics International 1997, 1997, pp. 178â188. [48] J. PopoviÂ´, S. Seitz, M. Erdmann, Z. PopoviÂ´, A. Witkin, Interactive c c manipulation of rigid body simulations, ACM Trans. Graph. (SIGGRAPH Proc.) 19 (2000) 209â217. [49] A. Treuille, A. McNamara, Z. Popovic, J. Stam, Keyframe control of smoke simulations, ACM Trans. Graph. (SIGGRAPH Proc.) 22 (2003) 716â723. [50] B. Boroomand, B. Khalilian, On using linear elements in incompressible plane strain problems: a simple edge based approach for triangles, Int. J. Num. Meth. Eng. 61 (2004) 1710â1740. [51] E. de Souza Neto, F. A. Pires, D. Owen, F-bar-based linear triangles and tetraehdra for ï¬nite strain analysis of nearly incompressible solids. part i: formulation and benchmarking, Int. J. Num. Meth. Eng. 62 (2005) 353â383. [52] F. A. Pires, E. de Souza Neto, D. Owen, On the ï¬nite element prediction of damage growth and fracture initiation in ï¬nitely deforming ductile materials, Comput. Meth. in Appl. Mech. and Eng. 193 (2004) 5223â5256. [53] Y. Guo, M. Ortiz, T. Belytschko, E. Repetto, Triangular composite ï¬nite elements, Int. J. Num. Meth. Eng. 47 (2000) 287â316. [54] P. Thoutireddy, J. Molinari, E. Repetto, M. Ortiz, Tetrahedral composite ï¬nite elements, Int. J. Num. Meth. Eng. 53 (2002) 1337â1351.

24

Fig. 6. A deformable Buddha with a cape undergoing large deformation when hit by a ball (top). The same with the Buddha removed to illustrate the deformation (bottom). (Cape - 84K triangles, Buddha - 357K tetrahedrons)

Fig. 7. A volumetric Buddha model is pushed down with a cylinder and pulled between rigid interlocking gears, then recovers its shape elastically. (300K tetrahedrons)

25

Fig. 8. A hexahedralized volume pulled between rigid interlocking gears. (56K hexahedrons)

Fig. 9. A plastic sphere controlled towards a ï¬attened disk shape is pulled through rigid interlocking gears (upper left, upper right, lower left). A more obvious example of plasticity control (lower right).

26

Fig. 10. Half of a torus (shell) simulated with in-plane and bending plasticity. (3.5K triangles).

Fig. 11. A Buddha undergoing ductile fracture. (300K tetrahedrons)

27

