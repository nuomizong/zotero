Computer-Aided Design 41 (2009) 47–58

Contents lists available at ScienceDirect

Computer-Aided Design
journal homepage: www.elsevier.com/locate/cad

Feature detection of triangular meshes based on tensor voting theory
Hyun Soo Kim, Han Kyun Choi, Kwan H. Lee ∗
Gwangju Institute of Science and Technology, 1 Oryong-dong, Buk-gu, Gwangju 500-712, Republic of Korea

article

info

a b s t r a c t
This paper presents n-dimensional feature recognition of triangular meshes that can handle both geometric properties and additional attributes such as color information of a physical object. Our method is based on a tensor voting technique for classifying features and integrates a clustering and region growing methodology for segmenting a mesh into sub-patches. We classify a feature into a corner, a sharp edge and a face. Then, finally we detect features via region merging and cleaning processes. Our feature detection shows good performance with efficiency for various dimensional models. Crown Copyright © 2009 Published by Elsevier Ltd. All rights reserved.

Article history: Received 21 May 2008 Accepted 3 December 2008 Keywords: Triangular mesh Feature detection Segmentation Tensor voting Clustering

1. Introduction In recent years there has been a renewal of interest in representing a model realistically as well as precisely since commercial scanning systems can obtain both geometry and color of an object with high speed and accuracy. The rapid growth of the ability of graphic hardware also facilitates this trend. Among others, triangular mesh has been widely used to describe a 3D model due to its simplicity and efficiency. It consists of vertices for geometrical position and edges for connectivity and topology. A mesh model which is generated by the latest 3D scanners also contains RGB color information of vertices. To represent and handle a model more efficiently, a triangular mesh often need additional attributes such as discrete curvature, texture coordinate and other properties. In this paper we use a general n-dimensional triangular mesh to accommodate multiple attributes. A 3D triangular mesh model can be created by scanning and modeling. With the advent of 3D color scanners, it is possible to generate a high-resolution model that contains millions of points and their color information simultaneously. Due to the occlusion problem of using the optical scanner, multiple scans are generally required for reconstructing a complete 3D model. The scanning operation often leads to a model having huge amount of data. Although the capability of computing resources has grown rapidly, the size of raw data is still too big to be managed in a modeling process and for many applications. Various mesh operations are combined together to solve this problem such as feature detection, segmentation, simplification and parameterization. Detecting the features of a model is usually performed in advance, because they

often represent crucial characteristics of the model and hence are used as constraints to other operations. Over the past few decades, there have been many studies on geometrical feature detection of 3D triangular meshes. However, little attention has been given to detect features of a triangular mesh that handles multiple attributes. We propose a new feature detection method for n-dimensional triangular meshes in this paper. The purpose of this paper is to detect sharp features of an n-dimensional triangle mesh by extending and modifying 3dimensional tensor voting theory. It will facilitate the complex modeling operations in reverse engineering. Our proposed method consists of five steps; eigen-analysis of the normal voting tensor, vertex clustering, region growing, region-merging and cleaning. The advantages of our algorithm are as follows:

• It can handle an n-dimensional triangular mesh. • It can detect both sharp features and smooth transition areas
simultaneously.

• It shows robustness to noisy data.
The rest of the paper is organized as follows. We review some of previous work related to feature detection in Section 2. Section 3 describes the main idea of our algorithm and several constraints. Section 4 presents the results of the proposed method and shows its performance by applying it to various models. Finally, Section 5 concludes the paper. 2. Related work Our primary concern in this paper is to detect features from a triangular mesh. Given a n-dimensional triangular mesh, we want to recognize feature points and sharp edges that can segment a model into several patches. There has been a considerable number of studies to solve the segmentation problem of a 3D object by

∗

Corresponding author. Tel.: +82 62 970 2386; fax: +82 62 970 2384. E-mail address: khlee@gist.ac.kr (K.H. Lee).

0010-4485/$ – see front matter Crown Copyright © 2009 Published by Elsevier Ltd. All rights reserved. doi:10.1016/j.cad.2008.12.003

48

H.S. Kim et al. / Computer-Aided Design 41 (2009) 47–58

using feature detection. The majority of early work deals with range images [1–6] or 3D point clouds [7–10]. Some recent studies have dealt with automatic detection of features directly from polygonal surfaces [56–59]. These are due to the rapid growth of applications which require a 3D physical model via a triangular mesh. Feature extraction has been studied from classical differential geometry [11–15]. From the differential geometric point of view, it is important to compute differential properties precisely. Most algorithms in computer graphics and geometry modeling have focused on how to approximate the first and second derivatives of a given mesh accurately. These differential quantities can be calculated through global or local surface fitting [15–19]. In general, global surface fitting methods [16,17] can calculate highorder derivatives and curvature extrema more accurately than local estimation methods. On the other hand, local estimation techniques [15,18,19] which use vertex coordinates of a point and its neighbor triangles show faster computation. Recently, several studies have been proposed to calculate discrete differential geometry directly from a mesh without approximation [20,21]. We can apply feature extraction techniques to various applications such as terrain data and medical image analysis [3,22–25], geometric modeling [18,26], non-photorealistic rendering [27,28], face modeling [51] and geomorphology [29]. Most of these previous approaches only consider shape information, and a significantly smaller number of studies has tried to extract features considering material properties of a physical model. Shape reconstruction has been a primary concern in reverse engineering because the shape of a model is more important than other properties for manufacturing so that 3D scanning systems used to acquire only geometric information. Recently the appearance of a product also becomes crucial in product development. Both the texture and the color of a model need to be considered in this case. Actually, it is often necessary to consider both geometry and other attributes for the applications which need to simulate or analyze a model with physical properties. Several researchers have conducted the modeling of triangular mesh using other attributes [30–34]. Most of them have tried to use texture or color information for mesh simplification. In order to decide the priority of simplification, it is necessary to measure the errors between the original model and the simplified model. Quadric error metric (QEM) is one of the most popular measures that can decide the priority of simplification [35,49]. QEM has been efficient in computing simplification errors and it is also easy to expand the dimension of mesh property. Garland and Heckbert generalized their earlier QEM scheme to handle additional surface properties [30]. One can decide the simplification priority by computing QEM using the normals of neighboring triangles of a vertex. However, the quadric error has several shortcomings to detect the features of a model. First of all, it is difficult for QEM to recognize different types of features such as corners, sharp edges and faces automatically. To solve this problem, we adopt Medioni’s tensor voting theory [36,37] and apply his theory to QEM. The second problem arises after the voting step. Since both QEM and tensor voting theory only consider vertices, it is hard to segment a region by the subsets of triangles. As a result, the boundaries between patches become either jagged or fuzzy. In order to obtain acceptable and clean boundaries, we apply a clustering technique which assigns vertices and triangles to the suitable patch. 3. The proposed method In this paper, we address the feature detection of n-dimensional triangular meshes containing surface noise. Tensor voting theory has great advantages in computer vision tasks such as segmentation and object recognition [36,47,48,50,52–55]. Since this theory can handle sharp features and shows robustness to noisy data,

Fig. 1. Outline of the proposed method.

we adopt tensor voting theory to analyze a surface shape. To handle n-dimensional triangular meshes, we extend and modify the original three-dimensional voting tensor. For a mesh segmentation algorithm, the estimation of curvature is the most important ingredient. Sun et al. [38] provided a good solution to this problem by using a normal voting tensor; however, their method can only detect sharp features such as corners and sharp edges. In other words, they can only recognize regions bounded by high curvature borders and fail to segment simple gradient areas where curvatures change smoothly. We solve this problem by combining the clustering and region growing technique. 3.1. Algorithm overview and notation Given a 2-manifold triangular mesh, the proposed method segments regions by classifying a mesh model into face, sharp edge, corner and transition border. Our algorithm is based on tensor voting theory [36] and consists of three steps: eigen-analysis of a normal voting tensor, clustering of vertex and region growing and cleaning (see Fig. 1). In order to apply tensor voting theory to triangular meshes, we calculate the normal voting tensors of vertices proposed in [38,39]. After acquiring the normal voting tensors, we analyze these tensors according to their eigen-values (see Section 3.2). In Section 3.3, we expand the 3-dimensional normal voting tensor into a higher-dimensional space for a mesh model which includes other attributes such as texture coordinate and color. And vertices are classified by the given number of clusters (see Section 3.4). Finally, we identify feature edges which can be classified into a sharp edge, a corner or a transition border by the region growing process and reconnect boundaries of regions by cleaning sequence [see Section 3.5]. Before describing our proposed method, we briefly introduce notation for the sake of clarity and compact expression. Table 1 lists the notations used in this paper to describe mathematical expressions and ingredients of mesh. 3.2. Eigen-analysis of normal voting tensor in 3D space The proposed method for feature detection is based on the normal voting tensor [38,39]. We implement the normal voting tensor of the triangular mesh proposed by Shimizu et al. [39]. The normal voting tensor is non-iterative and efficient to represent the local shape. It is robust to surface noise and can recognize features simultaneously. The basic concept and applications of tensor voting theory are introduced in [36]. In [39], Shimizu et al. proposed the edge strength for detecting feature vertices. Their edge strength can recognize high-curvature regions such as the vertices on sharp edges or at corners. However, it fails to extract the boundary of regions with simple curvature transition. We solve this problem by combining clustering and region growing.

H.S. Kim et al. / Computer-Aided Design 41 (2009) 47–58 Table 1 Notations used to describe mathematical expression and ingredients of mesh. Notations A a a M Explanations

49

vi

p eij hij ti nvi nti Nv (vi ) Nt (vi ) Nt (eij ) Tv

λi

ei qi

Matrix or tensor Vector Scalar value A triangular mesh which consists of geometric (vertices) and topological (edges, half-edges and triangles) primitives i-th vertex of M (x, y, z ) position vector of a point An edge of M connecting vi and vj A half-edge of M represented by the oriented vertex pair (vi , vj ). vi and vj are termed as origin and head of eij i-th triangle of M Unit normal of the vertex vi Unit normal of the triangle ti Neighbor vertices of the vertex vi Neighbor triangles of the vertex vi Neighbor triangles of the edge eij Normal voting tensor of a vertex v i-th eigen-value of tensor Tv i-th corresponding unit eigen-vector of λi i-th orthogonal basis of matrix. these orthogonal basis are always unit vectors

Fig. 2. 1-ring neighbor triangles of a vertex v and P(ti ) is a plane which contains the triangle ti . Fig. 3. 3-dimensional tensor decomposition.

The tensor voting theory for 3-dimensional triangular mesh is described in detail below. Normal voting tensors from a geometric viewpoint Medioni et al. [36] assign the voting tensor Tv of a vertex v in t an arbitrary point data set as a weight covariance matrix Vv which is called a vote. Sun et al. [38] define the normal voting tensor of a vertex on a triangular mesh by using the unit normal vectors of t neighbor triangles. If we consider the covariance matrix Vv of each t triangle ti in Fig. 2, Vv can be written by the unit normal of the triangle nti = (a, b, c ) by Eq. (1). a b c a2 c = ab ac

where

area(ti ): area of triangle ti area(max): maximum area among Nt (v) cti : barycenter of a triangle ti pv : position of a vertex v σ : an edge length of a cube that defines the neighboring space of each vertex.



Vv = nti ·

t

nTi t

=

· a

b

ab b2 bc

ac bc  . c2



Eigen-analysis of the normal voting tensor Because a normal voting tensor is a symmetric positive semidefinite second-order tensor, it can be diagonalized by eigenvalues (λ1 ≥ λ2 ≥ λ3 ≥ 0) and written by spectral representation as follows. Tv = λ1 e1 eT + λ2 e2 eT + λ3 e3 eT 1 2 3 where e1 , e2 , e3 are the corresponding unit eigen-vectors of λ1 , λ2 and λ3 respectively. The above formula can be decomposed into Tv = (λ1 − λ2 )e1 eT + (λ2 − λ3 )(e1 eT + e2 eT ) 1 1 2 (4)

(1)

Then the normal voting tensor Tv of a vertex v can be generated by the sum of the weighted covariance matrices of its neighbor triangles Tv =
ti ∈Nt (v)

µti nti nTi t

(2)

+ λ3 (e1 eT + e2 eT + e3 eT ) 1 2 3
e1 eT 1 e2 eT 2 e1 eT 1 e2 eT 2

(5)

where the weight is decided by the area ratio among neighbor triangles and the distance between the vertex and each triangle. Sun et al. [38] define the weight µti as follows

µti =

area(ti ) area(max)

exp −

cti − pv

σ /3

(3)

where describes a stick, + describes a plate, and e1 eT + + e3 eT describes a ball [36]. 1 3 Fig. 3 shows 3-dimensional decomposition of the tensor T . We can classify a vertex on the mesh into corner, sharp edge and face by the eigen-values of the tensor T . Shimizu et al. [39] propose the edge strength and classify vertices automatically. According to

50

H.S. Kim et al. / Computer-Aided Design 41 (2009) 47–58

Fig. 4. Eigen value of the normal voting tensor for different features.

their definition [39], the edge strength is about 1 if the vertex lies at the corner or on the sharp edge and is almost 0 if it lies on a face. Fig. 4 shows the characteristics of eigen-value of the normal voting tensor. Shimizu et al. [39] classify vertices into face, sharp edge and corner as follows.

• Face: λ1 is dominant, and λ2 and λ3 are close to 0. • Sharp edge: λ1 and λ2 are dominant, and λ3 is close to 0. • Corner: λ1 , λ2 and λ3 are approximately equal.
We cluster vertices according to the above rules. In Fig. 4, the magnitude of vectors are eigen-values and the directions of vectors are eigen-vectors. The eigen-vectors are mutually orthogonal. In general, the normal voting tensor has a unique solution because it is a symmetric positive semi-definite matrix. The pseudo-code for eigen-analysis of the normal voting tensor is shown in Fig. 5. We use the Jacobi method [40] to solve the eigen-system of each normal voting tensor. As a concrete example, we consider a numerical example of a simple mesh, especially the central vertex v7 in Fig. 6(a). The position vectors of vertices are listed in Fig. 6(b). Fig. 6(c) shows three vertices of which each triangle consists and all the information for calculating the weight µti of v7 . The triangle normals are also listed in the last column. Fig. 6(d) is the normal voting tensor of the central vertex v7 and the result of eigenanalysis. 3.3. Normal voting tensor for 2-manifold surface in nD space The normal voting tensor of n-dimensional triangular mesh is obtained as follows. In n-dimensional space, a tensor T of a 2 manifold surface has n orthogonal basis q1 , q2 , . . . , qn . This 2-manifold surface consists of two tangents q1 , q2 and n − 2 normals q3 , q4 , . . . , qn . For a triangle ti , two tangents q1 , q2 can be defined by Gram–Schmidt orthogonalization [44–46] (Fig. 7).

Fig. 5. Pseudo-code for eigen-analysis of normal voting tensor in 3D.

Since orthogonal basis q1 , q2 , . . . , qn is linearly independent n T t i=1 qi qi = I, we can obviously obtain the covariant matrix Vv as follows
t Vv = q3 qT + q4 qT + · · · + qn qT 3 4 n

= I − q1 qT − q2 qT . 1 2

(8)

By using the above expression, the normal voting tensor in n-dimensional space is defined as Tv =
t ∈Nt (v)

µ t nt nT t µt (qt qt T + qt qt T + · · · + qt qt T ) 3 3 4 4 n n
t ∈Nt (v)

= =
t ∈Nt (v)

µt (I − qt qt T − qt qt T ) 1 1 2 2
where t are neighbor triangles of vertex vi and µt is the weight defined in Eq. (3). (9)

(p2 − p1 ) |a| |p2 − p1 | c − (q1 · c )q1 q2 = |c − (q1 · c )q1 | where a = p2 − p1 and c = p3 − p1 .
q1 = a

=

(6)

In nD applications, various properties such as position, vertex color, texture coordinate and normal are handled together. For consistent results, it is required to scale the model so that it lies within the unit cube in Rn . In 6D case which uses the vertex color, the RGB color components are represented in the range of 0 ≤ r , g , b ≤ 1. Therefore, we only need to scale geometrical components(x, y, z ) in unit cube in R3 . In general, nD applications have n eigen-values. However, the relative difference between three smallest eigenvalues are important to perform clustering of vertices because we deal with 2-manifold surface. We only use three smallest eigenvalues for classifying vertices into face, sharp edge and corner as follows.

t Then, the covariant matrix Vv is expressed component-wise as follows t Vv = q3 qT + q4 qT + · · · + qn qT . 3 4 n

(7)

• Face: λn−2 is dominant, and λn−1 and λn are close to 0. • Sharp edge: λn−2 and λn−1 are dominant, and λn is close to 0. • Corner: λn−2 , λn−1 and λn are approximately equal.

H.S. Kim et al. / Computer-Aided Design 41 (2009) 47–58

51

Fig. 6. (a) Simple mesh with the size of the neighbor space σ = 3.987, (b) table of vertices, (c) table of triangles and (d) table of tensor, eigen-values and eigen-vectors of the central vertex v7 .

v2 is located on the geometrical sharp edge, so that it has larger λ4 , λ5 than λ6 . The vertex v3 lies at a colorimetric corner, as a result, λ4 , λ5 and λ6 are dominant. The vertices v4 and v5 which have dominant λ4 and λ5 lie on colorimetric sharp edges. The last vertex v6 is located on the intersection point of vertical geometric sharp
edge and horizontal colorimetric sharp edge. This causes the vertex v6 to be a new corner vertex in R6 , which has sufficiently large eigen-values λ4 , λ5 and λ6 . Since the scaling to balance geometry and color is applied before eigen-analysis, the proposed algorithm can deal with these different properties simultaneously. 3.4. Clustering for vertex classification After acquiring the eigen-values of all vertices, clustering process is performed to classify vertices through a certain number of clusters. We choose K-means algorithm [41] as our clustering algorithm because it is a simple and easy method to solve the

Fig. 7. Gram–Schmidt orthogonalization.

This means that (λ4,normalized , λ5,normalized , λ6,normalized ) are the data set for clustering in 6D case. Fig. 8 shows an example of 6D eigen-analysis. The model consists of two geometrical planes which make a right angle and also contains shapes of different vertex colors. The vertex v1 lies on the right plane with no color change. Since it is obvious that v1 is a geometrical and colorimetrical face vertex, both λ5 and λ6 of v1 are 0. The vertex

52

H.S. Kim et al. / Computer-Aided Design 41 (2009) 47–58

Fig. 9. Clustering of vertices; k, ε and qmax are the number of clusters, allowable position change of centroid and the maximum number of iterations respectively. Fig. 8. Eigen-analysis in 6D (a) simple mesh which consists of two geometrical plane with vertex color, (b) eigen-values.

action arises if the new centroids cp are different from the position of previous centroids In our implementation, the allowable position change of centroids ε and the maximum number of iterations qmax given by the user are applied to exit the feedback q q −1 loop and to avoid infinite loop. If cp − cp < ε for all clusters or q = qmax , the clustering is finished. Our clustering algorithm in nD case can be summarized as follows. (1) Initialize: Input three smallest and normalized eigen-value triples si,normalized by Eq. (10), the number of clusters k, the allowable position change of centroids and the maximum number of iterations qmax . Choose k vertices randomly as the initial centroid of each cluster. (2) Construct clusters: Integrate vertices into the closest cluster according to the distance between their eigen-value triple si,normalized and the centroid of each cluster (3) Update clusters: Recalculate the centroid of each cluster by averaging in the same cluster. (4) End condition: repeat step 2 and 3 until the distance between q−1 q the old centroid cp and the new centroid cp of each cluster is smaller than ε for all clusters or it reaches the maximum number of iterations qmax . Fig. 9 describes the process of our clustering. The number of clusters is set by the user. Fig. 10 shows a numerical example of K-means clustering in 3D case. Fig. 10(a) lists the original data set and its normalized data. In this example, we set k, ε and qmax to 3, 0.00001 and 10, respectively. Fig. 10(b) shows the position changes of three centroids during the clustering. Fig. 10(c) plots the normalized data. Our algorithm randomly chooses s9,normalized , s2,normalized and s10,normalized as the initial centroids in Fig. 10(d). Each normalized data is clustered to its closest cluster by calculating the distance between the normalized data and three centroids in Fig. 10(e). After a clustering is done, the update is performed by recalculating three new centroids (Fig. 10(f)). As it can be noticed, the clustering process exits the updating feedback loop after second iteration, since no more position change of three centroids occur between first and second iteration from Fig. 10(b). Our method detects smooth transition borders by fine classification of vertices via controlling the number of clusters. Most
q −1 cp .

q

well-known clustering problem. The initial data set si of our clustering algorithm in n dimension is a set of vectors which is composed of three smallest eigen-values of each vertex vi (si = {λn−2 , λn−1 , λn }). For example, si is the eigen-value triple of a vertex si = {λ1 , λ2 , λ3 } in 3D case. And we use si = {λ4 , λ5 , λ6 } as the data set in 6D case. Since the relative difference between eigenvalues is crucial to classify vertices in our method, the initial data set is normalized by Eq. (10), si,normalized = si / si . si,normalized = (λn−2,normalized , λn−1,normalized , λn,normalized ) (10)

λn−2,normalized = λn−1,normalized = λn,normalized =

λ n −2 λ n −1

λ2−2 + λ2−1 + λ2 n n n λ
2 n−2

+ λ2−1 + λ2 n n .

λn λ2−2 + λ2−1 + λ2 n n n

Now suppose that normalized data of m vertices si,normalized are given and it is required to classify them into k clusters (k < q m and 1 < i < m). Let cp be the mean or centroid of the normalized data in the cluster p after q-th iteration (1 ≤ p ≤ k). These centroids represent k different clusters. First step of our clustering process is to make initial guesses for the centroids 0 0 0 c1 , c2 , . . . , ck which are chosen randomly from {si,normalized }. The 0 next step is to assign si,normalized to the closest centroid cp and to integrate the vertex vi to the p cluster. When no vertex is pending, 1 1 1 k new centroids c1 , c2 , . . . , ck as barycenters of the clusters are recalculated. After we have these k new centroids, a new clustering has to be done between si,normalized and the nearest new centroid. A feedback loop has been generated. As a result of this feedback loop, the k centroids change their location and all vertices are regrouped to their respective clusters step by step until no more centroid positional changes occur. In other words, the backward

H.S. Kim et al. / Computer-Aided Design 41 (2009) 47–58

53

Fig. 10. Clustering example; (a) original data set si and normalized data set si,normalized , (b) initial guesses of centroids, (c) normalized data set, (d) initial guesses (e) clustering and (e) new centroids after first iteration.

Fig. 11. Three different results after clustering process; (a) two clusters, (b) three clusters and (c) five clusters are applied in each case.

work on feature detection and mesh segmentation only extracts the regions surrounded by high-curvature borders. In our algorithm, vertex clustering is applied in order to extract smooth transition regions. Our algorithm works since the cluster values between a smooth transition area and its neighbor region are usually different, even though curvature values of a surface changes smoothly. The number of clusters, of course, influences the

result in our proposed method. For example, the smooth transition area in Fig. 11 can be undetected by using the small number of clusters. Since the detection of a smooth region depends on the shape of a model, the user need to carefully choose the number of clusters. The color of each cluster is randomly chosen. In this paper, we experimentally set the number of clusters from 5 to 10.

54

H.S. Kim et al. / Computer-Aided Design 41 (2009) 47–58

Fig. 12. Seed triangle selection; (a) seed triangle case and (b, c, and d) other cases.

3.5. Region growing and merging Feature edges are identified in the region growing and merging process. Our region growing method is largely inspired by the work of Lavoué et al. [42]. We adapt their algorithm to tensor voting theory. The region growing process transfers the cluster information of vertices to triangles and consists of the triangle growing operation and the labeling operation. Before applying the region growing process, it is required to unlabel all triangles and to decide on seed triangles. We set a seed triangle which has its three vertices in the same cluster so that it can apply a triangle growing operation to its three neighbor triangles (see Fig. 12(a)). In other cases like Fig. 12(b), (c) and (d), we exclude these types of triangles from the seed triangle set. Our region growing process starts from an unlabeled seed triangle. When we find an unlabeled seed triangle, a new region with label L is created and set the triangle cluster as the same cluster of its three vertices. Next, we apply the region extension

test to the neighbor triangles whether they belong to the region L or not. If a neighbor triangle is not labeled and considered in the same region L, we associate this triangle into region L and set its triangle cluster by region extension test. If the new integrated triangle is set as a seed triangle, we exclude it from the seed triangle set. The triangle growing operation is recursively applied to the new integrated triangle. Fig. 13 shows the region extension test in detail. When we consider a triangle tL included in region L and its unlabeled neighbor triangle tU , we compare the cluster C(v2 ) of the vertex v2 with the triangle cluster C (tL ) of the triangle tL . If C (tL ) and C (v2 ) are the same as shown in Fig. 13(a), the neighbor triangle tU is integrated into the region L and the region extension test is recursively applied to neighbor triangles which share edge eb and ec . In other case, it is required to examine the clusters of vertex v0 and vertex v1 on edge etest . If C (tL ) and C (v2 ) are different and the cluster of the vertex on the edge etest is the same as C (tL ), we integrate tU into the region L and continue the region extension test to the edge which contains the vertex in the same cluster as tL . In Fig. 13(b), we continue the triangle growing operation to edge eb . If C (tL ) and C (v2 ) are different and the cluster of the vertex on the edge etest is different from C (tL ), we also integrate the triangle tU into region L. However, we quit the triangle growing operation to the edge which has no same cluster with respect to triangle tL such as edge ec in Fig. 13(b). The region growing process is repeated until there exists no unlabeled seed triangle. Upon completion of this process, small cracks can be created near the corner and the region borders. In this case, we integrate crack triangles into a suitable neighbor region by region merging process. These small cracks are merged to the neighbor region which has the closed centroid of eigen-values. We also apply the cleaning process that removes the branch of boundaries and completes borders of each region by using Demarsin et al.’s method [43]. For clear understanding of readers, Demarsin [43]’s method is briefly summarized below. After region growing and merging processes, there remain many branches. In order to clean these branches, the pruning and

Fig. 13. The region extension test.

Fig. 14. Cleaning process; (a) small branch example and (b) connection example from [43].

H.S. Kim et al. / Computer-Aided Design 41 (2009) 47–58

55

Fig. 15. (a) Fandisk with 6475 vertices and 12,946 triangles, (b) the intermediate result after vertex clustering and (c) the final output.

(a) Fandisk.

(b) Casting model: 5096 vertices and 10,224 triangles. Fig. 16. Comparison between Shimizu et al..s method [39] and our proposed method.

connecting algorithm proposed in [43] is applied to feature edges. The pruning process is to remove short branches. Short branches are detected by calculating the total length of edge segments which belong to a branch. Fig. 14(a) shows an example of a branch consisting of a set of edges whose lengths are li respectively. If m the total length of branch i=1 li is less than a given maximum branch length lmax , then the branch is removed. We set lmax to 10 times the average edge length for all tested models. The connection process begins after pruning step. For each end point pi , we search the set N of other end point qi within the neighbor space. 10-ring neighbor vertices are used as our neighbor space. At this point, we can classify end point pi into two cases. First, if there are at least one other end point qi in N, the end point pi is connected to the closest end point qi which does not generate a short cycle. A certain threshold l is used for detecting the short cycle. In our experiments, we set l to 20 times the average edge length. In Fig. 14(b), the path through the feature lines between p1 and q2 generates a short cycle, so that they do not connect to each other. However, q1 is a suitable candidate because there exists a long enough path between p1 and q1 . Therefore, p1 is linked to q1 . When connecting two end points, the shortest unconnected path between them is chosen to connect them. If there exists no good end point in N, pi is not connected to any end point qi like p2 and q3 in Fig. 14(b). Second, if there are no other end point in N, we link pi to the closest feature vertex which lies within neighbor space and do not generate a small cycle. For example, p3 is connected to q4 . However, p4 stays an end point, because the closest feature point q5 produces a small cycle. After the connection process, all remaining branches are removed. p2 ,q3 ,q2 and p4 in Fig. 14(b) are pruned. Then the cleaning process is completed. 4. Results and discussion Tensor voting in a 3-dimensional space Fig. 15 illustrates our proposed method step by step. The fandisk model which has 6475 vertices and 12,946 triangles is purely geometrical in Fig. 15(a). Fig. 15(b) shows the result after vertex classification using 5 clusters by eigen analysis of the normal voting tensor. The clustering terminates when the position difference of the cluster center during the iteration is less than 0.0001 or when the number of iterations is 100. We use the neighboring space as a

Fig. 17. Feature detection for noisy models (a) noisy mesh (b) Lavoué et al.’s segmentation algorithm [42] (c) Shimizu et al.’s method [39] (d) our method.

unit cube which has twice the average length of edges. Each cluster is rendered by five different randomly chosen vertex colors. The final features after applying region growing, merging and cleaning are demonstrated by red lines in Fig. 15(c). As shown in Fig. 15(c), our proposed method can detect not only sharp features but also smooth transition borders. To compare our proposed method with Shimizu et al.’s algorithm [39], we implement the feature detection algorithm using edge strength according to their publication. In Fig. 16, each left-side figure is the feature detection result [39] using their method and each right-side feature shows the result of our proposed method. We use the same normal voting tensor and its eigen-values. The neighboring space of the normal voting tensor is a unit cube which has twice the length of edges. We choose feature vertices whose edge strength are larger than 0.5 and feature edges whose inner product between edge direction and e3 vector of the vertex is larger than 0.9. We experimentally set the number of clusters, the difference of the cluster center and the maximum iteration to 5, 0.0001 and 100, respectively. We observe that the

56 Table 2 Computation time. Shimizu et al. [39]’s algorithm Eigen-analysis Edge streng – – Cleaning Total Fandisk (s) 0.078 0.013 – – 0.011 0.102

H.S. Kim et al. / Computer-Aided Design 41 (2009) 47–58

Casting (s) 0.062 0.011 – – 0.010 0.083

The proposed algorithm Eigen-analysis Vertex Clustering Region growing Region merging Cleaning Total

Fandisk (s) 0.078 4.469 0.015 0.016 0.012 4.59

Casting (s) 0.062 3.485 0.011 0.012 0.009 3.579

Fig. 18. Swirl model: 9216 vertices and 18,050 triangles from Garland [30].

edge strength by Sun et al.’s [39] can only detect sharp edges and corners. However, our algorithm can detect both sharp features and smooth transition borders. Table 2 lists the running time of each algorithm in each step. We ran these models on an Intel Pentium4-3.5GHz machine having 2G RAM. Our method takes more time due to the time spent in vertex clustering. Fig. 17 demonstrates the feature detection results for the same models having noisy data. We add Gaussian noise whose mean is zero and standard deviation is one tenth of the average edge length along the vertex normal direction (Fig. 17(a)). To evaluate our method, we make visual comparison with the notable published algorithms; Lavoué et al.’s segmentation [42] in

Fig. 17(b) and Shimizu et al.’s method [39] in Fig. 17(c). Lavoué et al.’s segmentation extracts over-segmented regions because the estimation of curvature is quite sensitive to badly tesselated objects. One solution for this problem is to suppress noise by using noise filtering or smoothing before calculating curvatures. Since Shimizu et al. apply the normal voting tensor as we do, their algorithm can also detect sharp edges and corners for noisy data. However, their work cannot detect smooth transition borders. The experiment set of neighbor space, the number of clusters, the difference of cluster centers and the maximum number of iterations are twice the average edge length, 5, 0.0001 and 100, respectively. In contrast to feature detection algorithms based on discrete curvature, our algorithm shows efficiency and robustness for noisy models due to the characteristics of the normal voting tensor (Fig. 17(d)). Tensor voting in a 4-dimensional space We apply the extended normal voting tensor to a 4-dimensional triangular mesh which has 3-dimensional geometric information and 8-bit gray-scale vertex color. Figs. 18 and 19 illustrate the results of the 4dimensional voting tensor. The neighboring space is a geometric

(a) Input model.

(b) Feature detection.

(c) Zoom-in view.

Fig. 19. Unit cube: 393,218 vertices and 786,432 triangles.

Fig. 20. Chess queen model: 4482 vertices and 8960 triangles.

H.S. Kim et al. / Computer-Aided Design 41 (2009) 47–58

57

and a cleaning operation. We can detect both sharp features and smooth transition areas simultaneously. The proposed algorithm is also robust to noisy data. We evaluate our algorithm using several models having various dimensional spaces. Our method takes more time than the method based on edge strength due to the additional vertex clustering operation. The future work will focus on making the clustering step faster and consider the automatic setting of parameters. Developing efficient postprocessing operations after region-growing and merging is another challenge. Acknowledgments This research is supported by the NRL (National Research Laboratory) funded by the Ministry of Education, Science and Technology of Korea. The rolling stage model in this paper is courtesy of IMATI and INRIA by the AIM@SHAPE Shape Repository. References
[1] Hoffman R, Jain AK. Segmentation and classification of range images. IEEE Transactions on Pattern Analysis and Machine Intelligence 1987;9(5):608–20. [2] Besl P. Surfaces in range image understanding. New York: Springer-Verlag; 1988. [3] Monga O, Benayoun S, Faugeras O. From partial derivatives of 3-D density images to ridge lines. In: Proceedings of CVPR. 1992. p. 354–9. [4] Rom H, Medioni G. Part decomposition and description of 3D shapes. In: International conference on pattern recognition, vol. 1. 1994. p. 629–32. [5] Loenardis A, Jaklie A, Solina F. Superquadrics for segmenting and modeling range data. IEEE Transactions on Pattern Analysis and Machine Intelligence 1997;19(11):1289–95. [6] López A M, Lumbreras F, Serrat J. Creaseness from level set extrinsic curvature. In: Proceedings of ECCV. 1998. p. 156–69. [7] Chaine R, Bouakaz S. Segmentation of 3-D surface trace points, using a hierarchical tree-based diffusion scheme. In: Proceedings of fourth Asian conference on computer vision ACCV, vol. 2. 2000. p. 995–1002. [8] Gumhold S, Wang X, Mcleod R. Feature extraction from point clouds. In: Proceedings of 10th international meshing roundtable. 2001. p. 293–305. [9] Chevalier L, Jaillet F, Baskurt A. A segmentation superquadric modeling of 3D objects. Proceedings of WSCG 2003;11(2):232–40. [10] Pauly M, Keiser R, Gross M. Multi-scale feature extraction on point-sampled models. Computer Graphics Forum: Eurographics 2003;22(3):281–9. [11] Koenderink JJ. Solid shape. MIT Press; 1990. [12] Porteous IR. Ridges and umbilics of surfaces. In: Martin RR, editor. The mathematics of surfaces II. Oxford: Clarendon Press; 1987. p. 447–58. [13] Belyaev AG, Anoshkina EV, Kunii TL. Ridges, ravines and singularities. Topological Modeling for Visualization, vol. 18. Springer; 1997. p. 375–83. [14] Hallinan PL, Gordon GG, Yuille AL, Giblin P, Mumford D. Two- and treedimensional patterns of the face. A K Peters; 1999. [15] Cazals F, Pouget M. Smooth surfaces, umbilics, lines of curvatures, foliations, ridges and the medial axis: a concise overview. Rapport de Recherche RR-5138. INRIA; 2004 (March). [16] Kent J T, Mardia K V, West J. Ridge curves and shape analysis. In: The British machine vision conference. 1996. p. 43–52. [17] Ohtake Y, Belyaev A, Seidel HP. Ridge-valley lines on meshes via implicit surface fitting. ACM Transactions on Graphics: Proc. ACM SIGGRAPH 2004; 23(3):609–12. [18] Stylianou G, Farin G. Crest lines for surface segmentation and flattening. IEEE Transactions on Visualization and Computer Graphics; 10(5); p. 536–44. [19] Gúeziec A. Large deformable splines, crest lines and matching. In: Proceedings of IEEE fourth int’l conf. computer vision. 1993. p. 650–7. [20] Lai YK, Zhou QY, Hu SM, Wallner J, Pottmann H. Robust feature classification and editing. IEEE Transactions on Visualization and Computer Graphics 2007; 13(1):34–45. [21] Hildebrandt K, Polthier K, Wardetzky M. Smooth feature lines on surface meshes. In: Eurographics symposium on geometry processing. 2005. p. 85–90. [22] Monga O, Armande N, Montesinos P. Thin nets and crest lines: Application to satellite data and medical images. Computer Vision and Image Understanding 1997;67(3):285–95. [23] Stylianou G. A feature based method for rigid registration of anatomical surfaces. In: Geometric modeling for scientific visualization. Springer Verlag; 2003. p. 139–52. [24] Pennec X, Ayache N, Thirion JP. Landmark-based registration using features identified through differential geometry. In: Bankman IN, editor. Handbook of medical imaging. Academic Press; 2000. p. 499–513. [25] Hoffman DD, Richards WA. Parts of recognition. Cognition 1985;18:65–96. [26] Hosaka M. Modeling of curves and surfaces in CAD/CAM. Berlin: Springer; 1992. [27] Interrante V, Fuchs H, Pizer S. Enhancing transparent skin surfaces with ridge and valley lines. In: Proceedings of IEEE visualization. 1995. p. 52–9.

Fig. 21. GIST-Ari model; 500,002 vertices and 1000,000 triangles.

unit cube with twice the average geometric edge length. In this test, we set the number of clusters, the center difference and the maximum number of iterations to 5, 0.0001 and 100, respectively. In addition, we scale the largest axis length of the geometric bounding box to 256 in order to establish the balance between the geometric space and gray color space. The model in Fig. 18 shows a swirl pattern on a geometrically smooth surface with vertex color. Since the vertex color smoothly changes from black to white, our algorithm detects these color transition area with two consecutive border-lines at color borders. In Fig. 19, we apply our algorithm to the unit cube which has both geometric sharp features and colorimetric sharp features. A close-up of the cube model is shown in Fig. 19(c). Our algorithm can successfully detect both geometric and colorimetric sharp features. Tensor voting in a 6-dimensional space Figs. 20 and 21 show algorithm applied to the model in a 6-dimensional space which includes 3-dimensional geometric information and 8-bits RGB vertex color information. The largest axis of the geometric bounding box is scaled to 256. The neighboring space is a geometric unit cube with twice the average of geometric edge length. We set the center difference and the maximum number of iterations to 0.0001 and 100. The number of clusters is 5 for the chess queen model and 20 for the GIST-Ari model, respectively. As shown in Figs. 20 and 21, our proposed method can efficiently detect n-dimensional features of the triangular mesh by using the extended normal voting tensor. 5. Conclusion In this paper, we present a new feature detection method for ndimensional triangular mesh. We successfully extend the original normal voting tensor by Gram–Schmidt orthogonalization. Our method consists of vertex clustering, region-growing, merging

58

H.S. Kim et al. / Computer-Aided Design 41 (2009) 47–58 [44] Strang G. Linear algebra and its applications. 3rd ed. Harcourt Brooks Cole; 1988. [45] Stoer J, Bulirsch R. Introduction to numerical analysis. 2nd ed. New York: Springer-Verlag; 1993 [chapter 6]. [46] Wilkinson JH, Reinsch C. Linear algebra. Handbook for automatic computation, vol. II. New York: Springer-Verlag; 1971. [47] Mordohai P, Medioni GG. Tensor voting. Morgan & Claypool Publishers; 2007. [48] Medioni GG, Lee MS, Tang CK. A compuational framework for segmentation and grouping. Elsevier; 2000. [49] Luebke D, Reddy M, Cohen J, Varshne A, Watson B, Huebner R. Level of detail for 3D graphics. Morgan Kaufmann; 2002. [50] Medioni G, François A. 3-D structures for generic object recognition. In: Proceedings of the international conference on pattern recognition, vol. 1. 2000. p. 30–7. [51] Fidaleo D. Model-assisted 3D face reconstruction from video. Analysis and modeling of faces and gestures. 2007. p. 124–38. [52] Min C, Medioni G. Motion segmentation by spatiotemporal smoothness using 5D tensor voting. 5th workshop on perceptual organization in computer vision, at CVPR; 2006. [53] Nicolescu M, Medioni G. 4-D voting for matching, densification and segmentation into motion layers. In: Proceedings of the international conference on pattern recognition, vol. 3. 2002. p. 303–8. [54] Dinh T. Two-frames accurate motion segmentation using tensor voting and graph cuts. Workshop on motion and video computing; 2008. [55] Alpert C, Yao S. Spectral partitioning: The more eigenvectors, the better. In: 32nd ACM/IEEE design automation conference. 1995. p. 195-200. [56] Lee Y, Lee S, Sharmir A, Cohen-OR D, Seidel H P. Intelligent mesh scissoring using 3D snakes. In: Proceedings of the 12th Pacific conference on computer graphics and applications. 2004. p. 279–87. [57] Li X, Toon T, Tan T, Huang Z. Decomposing polygon meshes for interactive applications. In: Proceedings of the 2001 symposium on interactive 3D graphics. 2001. p. 35–42. [58] Hubeli A, Gross M. Multiresolution feature extraction from unstructured meshes. In: Proceedings of the conference on visualization 2001. 2001. p. 287–94. [59] Antini G, Berretti S, Bimbo A D, Pala P. 3D mesh partitioning for retrieval by parts applications. In: Proc. IEEE international conference on multimedia & expo. 2005. p. 1210–13.

[28] Decarlo D, Finkelstein A, Rusinkiewicz S, Santella A. Suggestive contours for conveying shape. ACM Transactions on Graphics: Proc. ACM SIGGRAPH 2003; 22(3):848–55. [29] Little JJ, Shi P. Structural lines, TINs and DEMs. Algorithmica 2001;30(2): 243–63. [30] Garland M, Heckbert P. Simplifying surfaces with color and texture using quadric error metrics. In: Proc. of IEEE visualization. 1998. p. 263–70. [31] Kim SK, Lee J, Lim CS, Kim CH. Surface simplification with semantic features using texture and curvature maps. Lecture Notes in Computer Science 2005; 3482:1080–8. [32] Walter J D, Healey C G. Attribute preserving dataset simplification. In: Proceedings of the conference on visualization ’01. 2001. p. 113–20. [33] Fahn C S, Chen H K, Shiau Y H. Polygonal mesh simplification with face color and boundary edge preservation using quadric error metric. In: Proceedings of the IEEE international symposium on multimedia software engineering. 2002. p. 174–81. [34] Rigiroli P, Campadelli P, Pedotti A, Borghese NA. Mesh refinement with color attributes. Computers & Graphics 2001;25:449–61. [35] Garland M. Multiresolution modeling: Survey & future opportunities. State of the art report. Eurographics. 1999. [36] Medioni G, Tang C K. Tensor voting: Theory and applications. In: Proceedings of RFIA 2000. 2000. [37] Medioni G, Lee MS, Tang CK. A computational framework for segmentation and grouping. Amsterdam: Elsevier; 2000. [38] Sun Y, Page D L, Paik K, Koschan A, Abidi M A. Triangle mesh-based edge detection and its application to surface segmentation and adaptive surface smoothing. In: Proc. int. conf. image processing, vol. 3. 2002. p. 273–6. [39] Shimizu T, Date H, Kanai S, Kishinami T. A new bilateral mesh smoothing by recognizing features. In: Proceeding of ninth international conference on computer aided design and computer graphics. 2005. p. 281–6. [40] Press WH, Teukolsky SA, Vetterling WT, Flannery BP. Numerical recipes in C++. 2nd ed. Cambridge university press; 2002 [chapter 11]. [41] Gersho A, Gray R. Vector quantization and signal compression. Boston: Kluwer; 1992. [42] Lavoué G, Dupont F, Baskurt A. A new CAD mesh segmentation method, based on curvature tensor analysis. Computer-Aided Design 2007;37:975–87. [43] Demarsin K, Vanderstraeten D, Volodine T, Roose D. Detection of closed sharp edges in point clouds using normal estimation and graph theory. ComputerAided Design 2007;39(4):276–83.

